# Setup
```{r setup}
rm(list = ls())

# knitr options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, fig.align = 'center', fig.width = 10, fig.height = 7) 

# libraries
# library(ggBRT)
library(gbm)
library(dismo)
library(MASS)
library(dplyr)
library(gam)
library(mgcv)
library(ggplot2)
library(FSSgam)
library(corrplot)
library(corrr)
library(tidyverse)
library(magrittr)
library(sf)
# library(ggBRT)

# functions
source("./functions/brtFunc.R")
source("./functions/theme.R")

# Simulation
sim_name <- "sim1"

# Full data to predict to
# full_dat <- readRDS("./data/gpkg/sims/2.1_dat.gpkg")  # ATTRIBUTE MODEL
# full_dat <- read.csv("./data/02_data/2.1_dat_base.csv") # CHARLOTTE - NO SIM
# full_dat <- read.csv(paste0("./data/02_data/2.1_asc_rum_", sim_name,".csv")) %>% 
full_dat <- readRDS(paste0("./data/gpkg/sims/2.1_ascCS_rum_", sim_name,"_4283.gpkg")) %>% 
  mutate(season = ifelse(TripMonth %in% c("Sep", "Oct"), "Spring", 
                           ifelse(TripMonth %in% c("Jul", "Aug"), "Winter",
                                  "Autumn"))) %>% # ASC MODEL This section is now in wrangle so when you run that script again youb can get riude of this
  mutate(facYear = as.factor(numYear)) %>% 
  mutate(reefs = ifelse(is.na(reefs), 0, reefs)) %>% 
  mutate(lagoon = ifelse(is.na(lagoon), 0, lagoon)) 

# Data to model
dat <- full_dat %>% filter(choice == 1 & FishingType %in% "Demersal")
# dat <- full_dat %>% filter(choice == 1 & FishingType %in% "Demersal" & Site %in% c("TantabiddiBR", "CoralBayBR"))
```

# FSSgam
## Response
```{r}
# dat <- dat %>% # Jon doesn't have number of fish kept, just caught undamaged
#   mutate(CaughtUndam = as.integer(CaughtUndam)) %>%
#   mutate(caught_bin = ifelse(CaughtUndam > 0, 1, 0)) # potentially to test

resp <- dat$Dem 

which(is.na(dat$resp))
zeros <- round(nrow(dat[which(resp == 0),])/nrow(dat)*100, 2)
ggplot() +
  geom_histogram(data = dat, aes(x = resp), fill = "darkturquoise") +
  xlab("Demersal Catch") +
  ylab("Frequency") +
  annotate("text", x = 0, y = 10, label = paste0(zeros, "% zeros"), angle = 90) +
  theme_classic()

dat %<>% filter(Dem < 16)
```

## Vars to test
```{r}
# set the continuous predictors to test
# pred.vars <- c("dem", "depth", "l_km_br", "nl_km_br", "pelagic", "reef", "rreef", "lagoon", "decDuration", "rug", "centroidLat") # FOR CHARLOTTE
pred.vars <- c("depth", "km_BR", "reefs", "lagoon", "decDuration", "rug", "MedianHour", "exTimes12m", "centLat") # ASC
# pred.vars <- c("CaughtUndam", "depth", "pelagic", "reef", "rreef", "lagoon", "decDuration", "rug", "centLat", "MedianHour", "exTimes12m", "ln_km_br") # ATTRIBUTE


# factor vars 
# factor.vars <- c("season", "BaitLure") # east/west model
factor.vars <- c("season", "BaitLure", "gulf")
dat %<>% mutate(across(all_of(c(factor.vars)), as.factor))

# rum.vars
rum.vars <- c("fcflt_spgam", "swell")
```


## NAs
There needs to be no NAs in the predictors in the full data set the model can predict on to teh full data set. 
```{r}
# check continuous vars 
summary(full_dat[,pred.vars]) 
pred.vars <- pred.vars[ !pred.vars == "exTimes12m"] # remove 

full_dat

# check factors vars
names(which(colSums(is.na(dat[,factor.vars]))>0)) 
factor.vars <- factor.vars[ !factor.vars == "BaitLure"] # remove 
```

## Correlation
Check the correlation between the catch and rum predictors. 
```{r}
# Check the correlations between predictor variables - remove if over 95
correlate(dat[,c(pred.vars, rum.vars)], use = "complete.obs") %>%  
  gather(-term, key = "colname", value = "cor") %>% 
  dplyr::filter(abs(cor) > 0.5) %>% 
  arrange(-cor) %>% 
  distinct(cor, .keep_all = TRUE)

pred.vars <- pred.vars[ !pred.vars == "km_BR"] # remove high correlations
```


## Outliers
Check for outrageous outliers that need to be removed from the data. 
```{r}
par(mfrow = c(1,2))
for (i in pred.vars) {
  x <- dat[,i]
  x = as.numeric(unlist(x))
  hist((x), main = paste(i))
  plot((x), main = paste(i))
}
```

## Tranformations
Aiming for homoscedascit, normal distribution, however avoid transformation where possible. 
```{r}
  par(mfrow = c(3,4))

  for (i in pred.vars) {
    
    tryCatch({
      
       x <- dat[,i]
       x = as.numeric(unlist(x))
       hist((x))
       plot((x), main = paste(i))
       hist(sqrt(x))
       plot(sqrt(x))
       hist(log(x + 1))
       plot(log(x + 1))
       hist((x))
       plot((x), main = paste(i))
       hist((x)^2)
       plot((x)^2)
       hist((x)^3)
       plot((x)^3)
       
    }, error = function(e) {
      # Handle the error if necessary
      print(paste("Unable to transform", i, ":", e))
    }
    )
  }

  # Make transformations
  # ASC
  dat$log_depth <- log(dat$depth + 1)
  
  
  full_dat$log_depth <- log(full_dat$depth + 1)

  # Attribute
  # dat$log_depth <- log(dat$depth + 1)
  # dat$log_reef <- log(dat$reef + 1)
  # dat$log_rreef <- log(dat$rreef + 1)
  # dat$log_lagoon <- log(dat$lagoon + 1)
  # dat$sqrt_decDuration <- sqrt(dat$decDuration)
  # dat$sqrt_rug <- sqrt(dat$rug)
  # dat$log_avid <- log(dat$exTimes12m + 1) 
  #log_nl_km_br # already in data
  
  # dat$log_lkm_br <- log(dat$l_km_br + 1) # CHARLOTTE
  # dat$log_nlkm_br <- log(dat$nl_km_br + 1) # CHARLOTTE
```

## Assign pred.vars
```{r}
  # update continous predictors
# pred.vars <- c("log_depth","log_nlkm_br","pelagic", "log_reef", "log_rreef", "log_lagoon", "sqrt_decDuration", "sqrt_rug", "centroidLat") # CHARLOTTE
pred.vars <- c("log_depth", "reefs", "lagoon", "rug", "MedianHour", "centLat") # ASC
# pred.vars <- c("log_depth","log_nl_km_br", "log_reef", "log_rreef", "log_lagoon", "sqrt_rug", "centLat", "log_avid", "MedianHour") # Attribute
```

# Model selection
  - k is knows determines out wavy we allow the line to be - the higher the knots the smoother and more risk of over fitting: max 5
  - cr is a cubic spline
  - re = random effect

```{r GAMMs}
# creating  empty lists
out.all <- list()
var.imp <- list()
fss.all = list()
top.all = list()

# test model
# test_fit <- gam(Dem ~ s(log_depth, k = 3, bs = "cr") + s(PersonID, bs = 're'), family = tw(), data = dat) # CHARLOTTE
test_fit <- gam(Dem ~ s(log_depth, k = 3, bs = "cr") + s(PersonID, bs = 're') + s(facYear, bs = 're'), 
                offset = decDuration, family = tw(), data = dat) # PhD

# model selection
model.set <- generate.model.set(use.dat = dat,
                                test.fit = test_fit,
                                pred.vars.cont = pred.vars,
                                pred.vars.fact = factor.vars,
                                max.predictors = 5,
                                k = 3,
                                null.terms = "s(PersonID, bs = 're') + s(facYear, bs = 're')",
                                smooth.smooth.interactions = F,
                                factor.factor.interactions = F,
                                cov.cutoff =  T)


  out.list <- fit.model.set(model.set, max.models = 600, parallel = T)
  
  # saveRDS(out.list, file = "./models/catch/outlist.Rdata")
  # test <- readRDS("./models/catch/outlist.Rdata")
  
  names(out.list)
  
  out.list$failed.models # examine the list of failed models
  mod.table <- out.list$mod.data.out  # look at the model selection table
  mod.table <- mod.table[order(mod.table$AICc), ]
  mod.table$cumsum.wi <- cumsum(mod.table$wi.AICc)
  out.i   <- mod.table[which(mod.table$delta.AICc <= 2), ]
  out.all <- c(out.all,list(out.i))
  var.imp <- c(var.imp,list(out.list$variable.importance$aic$variable.weights.raw)) # Or importance score weighted by r2
  
  # plot the best models
  # for (m in 1:nrow(out.i)) {
  #   best.model.name = as.character(out.i$modname[m])
  #   if (best.model.name != "null") {
  #     # par(mfrow = c(3, 1), mar = c(9, 4, 3, 1))
  #     best.model = out.list$success.models[[best.model.name]]
  #     plot <- plot(best.model, all.terms = T, pages = 1, residuals = T, pch = 16, shade = TRUE)
  #     # mtext(side = 2, text = resp.vars[i], outer = F)
  #     
  #     pred_plots <- plot[[m]]
  #     }  
  # }
  
  all.mod.fits   <- do.call("rbind",out.all)
  all.var.imp    <- do.call("rbind",var.imp)
```

## Top Model
```{r}
all.var.imp %<>% 
  as.data.frame() %>% 
  gather(key = predictor, value = importance) %>%
  mutate(model = "Catch") %>% 
  arrange(desc(importance))

# Plot gg.importance.scores
  ggplot(all.var.imp, aes(y = reorder(predictor, importance), x = importance, fill = importance)) +
    geom_col(show.legend = F) +
    xlab("Importance") +
    ylab("Predictor") +
    theme_classic()
  
  mod.table[1, "formula"]
  
# Make top model
topmod <- gam(Dem ~ 
              # ASC
              s(centLat, k = 3, bs = "cr") +
              s(MedianHour, by = gulf, k = 3, bs = "cr") +
              s(rug, by = gulf, k = 3, bs = "cr") +
              s(lagoon, k = 3, bs = "cr") +
              gulf + 
                
              # ATRRIBUTE 
              # s(log_depth, k = 3, bs = "cr") +
              # s(log_rreef, k = 3, bs = "cr") +
              # s(log_lagoon, by = season, k = 3, bs = "cr") +
              # s(log_reef, by = season, k = 3, bs = "cr") +
              # season +
                
              s(PersonID, bs = 're') +
              s(facYear, bs = 're'),
              offset = decDuration,
              method = "REML",
              family = tw(), 
              data = dat)

# saveRDS(topmod, file = "./models/catch.rda")
# topmod <- readRDS("./models/catch.rda")

summary(topmod)
AIC(topmod)

par(mfrow = c(2,2)) 
gam.check(topmod)

par(mfrow = c(3,4)) 
plot(topmod, all.terms = TRUE, residuals = TRUE, pch = 16, shade = TRUE)
```

# Prediction
```{r}
full_dat %<>% dplyr::select(-c(p_dem.fit, p_dem.se.fit))

# Predict model onto big data
full_dat <- cbind(full_dat,
                "p_dem" = predict(topmod, newdata = full_dat, type = 'response', se.fit = T))

full_dat %<>%
  mutate(p_dem.fit = round(p_dem.fit), p_dem.se.fit = round(p_dem.se.fit, 2))

# Check summary
summary(full_dat$p_dem.fit)

ggplot() +
  geom_histogram(data = full_dat, aes(x = p_dem.fit), fill = "darkturquoise") +
  xlab("Predicted Catch") +
  ylab("Frequency") +
  annotate("text", x = 0, y = 10, label = paste0(zeros, "% zeros"), angle = 90) +
  theme_classic()
```

## Spatial Predictions
### Attribute
```{r}
# find average fisher
# n19 <- dat[(dat$gridID_alt %in% '19' & dat$season %in% "Autumn" & dat$TimeOfDay %in% "Midday"),]
# n19
# 1275
#72

grid <- full_dat %>% 
  filter(TripID == 992) %>%
  st_as_sf()

ggplot() +
  geom_sf(data = grid$asc_geom, aes(fill = grid$p_dem.fit), lwd = 0.05) +
  # scale_fill_distiller(palette = "YlGnBu", direction = 1) +
  labs(fill = "Demersal\nCatch") +
  theme_classic()

ggplot() +
  geom_sf(data = grid$asc_geom, aes(fill = grid$p_dem.se.fit), lwd = 0.05) +
  scale_fill_distiller(palette = "YlGnBu", direction = -1) +
  labs(fill = "Error: Demersal\nCatch") +
  theme_classic()
```
# Store
Need a data set with no geometry for stata
## ASC
```{r}
write_csv(full_dat, paste0("./data/02_data/2.3_asc_dat_", sim_name, ".csv")) # ASC

# ATTRIBUTE
# grid %<>% dplyr::select(gridid_alt, br_geom, dat_geom, grid_geom) # spatial data to join later
# saveRDS(grid, "./data/gpkg/att_sp_dat.gpkg")
# 
# full_dat %<>% dplyr::select(-c(br_geom, dat_geom, grid_geom))
# write_csv(full_dat, "./data/02_data/2.3_dat_att.csv")

# CHARLOTTE
# grid %<>% dplyr::select(gridid_alt, br_geom, dat_geom, grid_geom) # spatial data to join later
# saveRDS(grid, "./data/gpkg/att_sp_dat.gpkg")
# 
# full_dat %<>% dplyr::select(-c(br_geom, dat_geom, grid_geom))
# write_csv(full_dat, "./data/02_data/2.3_dat.csv")
```

# BRTs
## BRT loop
```{r}
# define response
  resp <- which(colnames(dat) == "Dem") # poisson
  # resp <- which(colnames(dat) == "demph") # poisson
  # resp <- which(colnames(dat) == "dem_bin") # bernoulli

# defining covariates
  pred.vars <- c("Depth", "km_BR", "Pelagic", "Reef", "RReef", "Lagoon", "centroidLat", "decDuration") # covs for dem and dem_bin
  # pred.vars <- c("Depth", "km_BR", "Pelagic", "Reef", "RReef", "Lagoon", "centroidLat") # covs fro demph (remove duration)
    
# Set up CV
  k = 10 #number of folds
  p <- unique(dat$PersonID)
  p <- data.frame(PersonID = (sample(p)))# shuffle the data
  p$k <- c(rep(1:k, floor(nrow(p)/k)), sample(1:k, size = nrow(p) - length(rep(1:k, floor(nrow(p)/k)))))
  dat <- left_join(dat, p, by = "PersonID")
  table(dat$k) #k provides indicator for 10 fold cross validation

# define parameters for gbm.step to loop over
  step.loop <- expand.grid(lr = c(0.01, 0.001, 0.0001), # min
                           tc = c(5, 7, 10), # 1-5
                           bf = c(0.5, 0.65, 0.75), # max 0.75
                           ss = c(3, 5, 7)) 

  step.loop$n.trees <- NA ## add res.dev to grid
  step.loop$res.dev <- NA ## add res.dev to grid
  
  nmods <- nrow(step.loop)
  print(paste0("Making ", nmods, " models"))

for (i in 1:nrow(step.loop)) {
  print(i)
  
  tryCatch(
    {
      result <- gbm.step(data = dat,
                         gbm.x = pred.vars, ## covariates
                         gbm.y = resp, ## response
                         fold.vector = dat$k,
                         n.folds = k,
                         lr = step.loop[i, "lr"], ## ref to step.loop
                         tree.complexity = step.loop[i, "tc"], ## ref to step.loop
                         family = "poisson", ## distribution family
                         bag.fraction = step.loop[i, "bf"],
                         step.size = step.loop[i, "ss"],
                         plot.main = FALSE,
                         silent = T)
      
      step.loop[i, "nt"] <- result$n.trees
      step.loop[i, "res.dev"] <- result$self.statistics$mean.resid ### store res.dev in step.loop
      
      step.loop %<>% arrange(res.dev)
    },
    error = function(e) {
      # Handle the error if necessary
      print(paste("Error occurred in iteration", i, ":", e))
    }
  )
}
```
## Separate BRTs
```{r dp.step loop, warning=FALSE}
## Demersal catch
resp <- c("Dem") # poisson
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat", "decDuration"))

dem_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           fold.vector = dat$k,
                           # offset = dat$decDuration,
                           n.folds = k,
                           lr = 0.0001, 
                           tree.complexity = 5, 
                           family = "poisson", ## distribution family
                           bag.fraction = 0.75,
                           step.size = 2
                         )

## demersal catch binary
resp <- which(colnames(dat) %in% "dem_bin") # bernoulli
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat", "decDuration"))


dem_bin_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           family = "bernoulli",
                           tree.complexity = 5,
                           learning.rate = 0.01,
                           bag.fraction = 0.5,
                           step.size = 3,
                           fold.vector = dat$k,
                           n.folds = k,
                         )


## Demersal catch per hour
resp <- which(colnames(dat) == "demph") # poisson
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat"))

dem_mph_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           fold.vector = dat$k,
                           n.folds = k,
                           lr = 0.01, 
                           tree.complexity = 3, 
                           family = "poisson", ## distribution family
                           bag.fraction = 0.5,
                           step.size = 5,
                           n.trees = 1000)
```