# Setup
```{r setup}
rm(list = ls())

# knitr options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, fig.align = 'center', fig.width = 10, fig.height = 7) 

# libraries
# library(ggBRT)
library(gbm)
library(dismo)
library(MASS)
library(dplyr)
library(gam)
library(mgcv)
library(ggplot2)
library(FSSgam)
library(corrplot)
library(corrr)
library(tidyverse)
library(magrittr)
library(sf)
# library(ggBRT)

# functions
source("./functions/brtFunc.R")
source("./functions/theme.R")

# data
# full_dat <- read.csv("./data/02_data/2.2_dat.csv")
# sp_dat <- readRDS("./data/gpkg/sims/2.1_dat.gpkg")

full_dat <- readRDS("./data/02_data/2.2_Site_4283.gpkg")
```

# Data Prep
```{r data exploration}
# Filter data
dat <- full_dat %>% filter(choice == 1)

# Adding predictors
dat <- dat %>% 
  mutate(Dem = as.integer(Dem)) %>%
  filter(Dem < 50) %>% 
  mutate(demph = as.integer(Dem/decDuration)) %>% 
  mutate(dem_bin = ifelse(Dem > 0, 1, 0))

dat %<>% 
  mutate(centroidLat = st_coordinates(dat)[,2]) %>%
  st_drop_geometry() %>% 
  as.data.frame()
  

# Set the predictors for modeling
pred.vars <- c("Dem", "depth", "l_km_br", "nl_km_br", "pelagic", "reef", "rreef", "lagoon", "decDuration", "centroidLat") 

# Check there is no NAs
summary(dat[,pred.vars])

# Check the correlations between predictor variables - remove if over 95
correlate(dat[,pred.vars], use = "complete.obs") %>%  
  gather(-term, key = "colname", value = "cor") %>% 
  dplyr::filter(abs(cor) > 0.5)

# Plot transformations - need to run in console
  par(mfrow = c(3,4))

  for (i in pred.vars) {
    
    tryCatch({
      
       x <- dat[,i]
       x = as.numeric(unlist(x))
       hist((x))
       plot((x), main = paste(i))
       hist(sqrt(x))
       plot(sqrt(x))
       hist(log(x + 1))
       plot(log(x + 1))
       hist((x))
       plot((x), main = paste(i))
       hist((x)^2)
       plot((x)^2)
       hist((x)^3)
       plot((x)^3)
       
    }, error = function(e) {
      # Handle the error if necessary
      print(paste("Unable to transform", i, ":", e))
    }
    )
  }
  
  # Make transformations
  dat$log.dem <- log(dat$Dem + 1)
  dat$log.depth <- log(dat$depth + 1)
  dat$log.l_km_br <- log(dat$l_km_br + 1)
  dat$log.nl_km_br <- log(dat$nl_km_br + 1)
  dat$log.reef <- log(dat$reef + 1)
  dat$log.rreef <- log(dat$rreef + 1)
  dat$log.lagoon <- log(dat$lagoon + 1)
  dat$sqrt.decDuration <- sqrt(dat$decDuration)
  
  # update predictors
pred.vars <- c("log.depth","log.l_km_br", "log.nl_km_br","pelagic", "log.reef", "log.rreef", "log.lagoon", "sqrt.decDuration", "centroidLat") 
```

# BRTs
## BRT loop
```{r}
# define response
  resp <- which(colnames(dat) == "Dem") # poisson
  # resp <- which(colnames(dat) == "demph") # poisson
  # resp <- which(colnames(dat) == "dem_bin") # bernoulli

# defining covariates
  pred.vars <- c("Depth", "km_BR", "Pelagic", "Reef", "RReef", "Lagoon", "centroidLat", "decDuration") # covs for dem and dem_bin
  # pred.vars <- c("Depth", "km_BR", "Pelagic", "Reef", "RReef", "Lagoon", "centroidLat") # covs fro demph (remove duration)
    
# Set up CV
  k = 10 #number of folds
  p <- unique(dat$PersonID)
  p <- data.frame(PersonID = (sample(p)))# shuffle the data
  p$k <- c(rep(1:k, floor(nrow(p)/k)), sample(1:k, size = nrow(p) - length(rep(1:k, floor(nrow(p)/k)))))
  dat <- left_join(dat, p, by = "PersonID")
  table(dat$k) #k provides indicator for 10 fold cross validation

# define parameters for gbm.step to loop over
  step.loop <- expand.grid(lr = c(0.01, 0.001, 0.0001), # min
                           tc = c(5, 7, 10), # 1-5
                           bf = c(0.5, 0.65, 0.75), # max 0.75
                           ss = c(3, 5, 7)) 

  step.loop$n.trees <- NA ## add res.dev to grid
  step.loop$res.dev <- NA ## add res.dev to grid
  
  nmods <- nrow(step.loop)
  print(paste0("Making ", nmods, " models"))

for (i in 1:nrow(step.loop)) {
  print(i)
  
  tryCatch(
    {
      result <- gbm.step(data = dat,
                         gbm.x = pred.vars, ## covariates
                         gbm.y = resp, ## response
                         fold.vector = dat$k,
                         n.folds = k,
                         lr = step.loop[i, "lr"], ## ref to step.loop
                         tree.complexity = step.loop[i, "tc"], ## ref to step.loop
                         family = "poisson", ## distribution family
                         bag.fraction = step.loop[i, "bf"],
                         step.size = step.loop[i, "ss"],
                         plot.main = FALSE,
                         silent = T)
      
      step.loop[i, "nt"] <- result$n.trees
      step.loop[i, "res.dev"] <- result$self.statistics$mean.resid ### store res.dev in step.loop
      
      step.loop %<>% arrange(res.dev)
    },
    error = function(e) {
      # Handle the error if necessary
      print(paste("Error occurred in iteration", i, ":", e))
    }
  )
}
```

## Separate BRTs
```{r dp.step loop, warning=FALSE}
## Demersal catch
resp <- c("Dem") # poisson
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat", "decDuration"))

dem_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           fold.vector = dat$k,
                           # offset = dat$decDuration,
                           n.folds = k,
                           lr = 0.0001, 
                           tree.complexity = 5, 
                           family = "poisson", ## distribution family
                           bag.fraction = 0.75,
                           step.size = 2
                         )

## demersal catch binary
resp <- which(colnames(dat) %in% "dem_bin") # bernoulli
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat", "decDuration"))


dem_bin_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           family = "bernoulli",
                           tree.complexity = 5,
                           learning.rate = 0.01,
                           bag.fraction = 0.5,
                           step.size = 3,
                           fold.vector = dat$k,
                           n.folds = k,
                         )


## Demersal catch per hour
resp <- which(colnames(dat) == "demph") # poisson
pred.vars <- which(colnames(dat) %in% c("Depth", "km_BR", "centroidLat"))

dem_mph_mod <- dismo::gbm.step(data = dat,
                           gbm.x = pred.vars, ## covariates
                           gbm.y = resp, ## response 
                           fold.vector = dat$k,
                           n.folds = k,
                           lr = 0.01, 
                           tree.complexity = 3, 
                           family = "poisson", ## distribution family
                           bag.fraction = 0.5,
                           step.size = 5,
                           n.trees = 1000)
```


# FSS gams
### Gam prep
Need less than 80% zeros in response
```{r zeros}
# For if you hav e one column with multiply responses
# unique.vars <- unique(as.character(dat$scientific)) 
# 
# resp.vars <- character()
# for(i in 1:length(unique.vars)){
#   temp.dat <- dat[which(dat$scientific == unique.vars[i]), ]
#   if(length(which(temp.dat$maxn == 0)) / nrow(temp.dat) < 0.8){ # Change here
#     resp.vars <- c(resp.vars, unique.vars[i])}
# }
# resp.vars   

# For when you only have one response
# define response
resp <- dat$Dem # 81% zeros
# resp <- dat$demph # 86% zeros
# resp <- dat$demph # 86% zeros

zeros <- round(nrow(dat[which(resp == 0),])/nrow(dat)*100, 2)

ggplot() +
  geom_histogram(data = dat, aes(x = Dem), fill = "darkturquoise") +
  xlab("Demersal Catch") +
  ylab("Frequency") +
  annotate("text", x = 0, y = 100, label = paste0(zeros, "% zeros"), angle = 90) +
  theme_classic()
```

## Model selection
  - k is knows determines out wavy we allow the line to be - the higher the knots the smoother and more risk of over fitting: max 5
  - cr is a cubic spline
  - re = random effect

```{r GAMMs}
# creating  empty lists
out.all <- list()
var.imp <- list()
fss.all = list()
top.all = list()
# resp.vars = unique.vars.use

# test model
test_fit <- gam(Dem ~ s(log.depth, k = 3, bs = 'cr') + s(PersonID, bs = 're'), family = 'poisson', data = dat)

# model selection
model.set <- generate.model.set(use.dat = dat, 
                                test.fit = test_fit, 
                                pred.vars.cont = pred.vars, 
                                max.predictors = 5,
                                k = 3, 
                                null.terms = "s(PersonID, bs = 're')", 
                                smooth.smooth.interactions = F, 
                                factor.factor.interactions = F,
                                cov.cutoff =  T)


  out.list <- fit.model.set(model.set, max.models = 600, parallel = T)
  names(out.list)
  
  out.list$failed.models # examine the list of failed models
  mod.table <- out.list$mod.data.out  # look at the model selection table
  mod.table <- mod.table[order(mod.table$AICc), ]
  mod.table$cumsum.wi <- cumsum(mod.table$wi.AICc)
  out.i   <- mod.table[which(mod.table$delta.AICc <= 2), ]
  out.all <- c(out.all,list(out.i))
  var.imp <- c(var.imp,list(out.list$variable.importance$aic$variable.weights.raw)) # Or importance score weighted by r2
  
  # plot the best models
  for (m in 1:nrow(out.i)) {
    best.model.name = as.character(out.i$modname[m])
    if (best.model.name != "null") {
      # par(mfrow = c(3, 1), mar = c(9, 4, 3, 1))
      best.model = out.list$success.models[[best.model.name]]
      plot <- plot(best.model,all.terms = T, pages = 1, residuals = T, pch = 16)
      # mtext(side = 2, text = resp.vars[i], outer = F)
      
      pred_plots <- plot[[m]]
      }  
  }
  
  
  all.mod.fits   <- do.call("rbind",out.all)
  all.var.imp    <- do.call("rbind",var.imp)
```
## Top Model
```{r}
all.var.imp %<>% 
  as.data.frame() %>% 
  gather(key = predictor, value = importance) %>%
  mutate(model = "Catch") %>% 
  arrange(desc(importance))

# Plot gg.importance.scores
  ggplot(all.var.imp, aes(y = reorder(predictor, importance), x = importance, fill = importance)) +
    geom_col(show.legend = F) +
    xlab("Importance") +
    ylab("Predictor") +
    theme_classic()
  
# Make top model
topmod <- gam(log.dem ~ 
                s(log.depth, k = 3, bs = 'cr') + 
                s(sqrt.decDuration, k = 3, bs = 'cr') +
                s(centroidLat, k = 3, bs = 'cr') + 
                s(log.reef, k = 3, bs = 'cr') +
                s(log.lagoon, k = 3, bs = 'cr') + 
                s(PersonID, bs = 're'), 
              family = 'poisson', 
              data = dat)

summary(topmod)
AIC(topmod)
```

## Predictions
```{r}
 # Make transformations
  full_dat$Depth <- abs(full_dat$Depth)
  full_dat$log.Depth <- log(full_dat$Depth + 1)
  full_dat$log.Reef <- log(full_dat$Reef + 1)
  full_dat$log.Lagoon <- log(full_dat$Lagoon + 1)
  full_dat$sqrt.decDuration <- sqrt(full_dat$decDuration)

# Predict model onto big data
full_dat <- cbind(full_dat, 
                "p_dem" = predict(topmod, newdata = full_dat, type = 'response', se.fit = T))

full_dat %<>% 
  mutate(p_dem.fit = round(p_dem.fit, 2), p_dem.se.fit = round(p_dem.se.fit, 2))

# Check summary
summary(full_dat$p_dem.fit)
```

## Predictor plots
```{r}
# define top mod predictors
# top.preds <- c("log.Depth", "log.Reef", "log.Lagoon", "sqrt.decDuration", "centroidLat")
# 
# grids <- full_dat %>% distinct(gridID_alt, .keep_all = TRUE)
# 
# # only works for spatial vars nmot people vars
# for (i in 1:length(top.preds)) {
#   plot <- ggplot(data = grids, aes_string(x = top.preds[i], y = "p_dem.fit")) +
#     ylab("Predicted demersal catch") +
#     geom_smooth(alpha = 0.75, size = 2, show.legend = FALSE) +
#     theme_classic()
#   
#   plots[[i]] <- plot  # Add the plot to the list
# }
# 
# plots
# 
# people vars
# t <- full_dat %>% distinct(PersonID, .keep_all = TRUE)
# 
# ggplot(data = t, aes(x = sqrt.decDuration, y = "p_dem.fit")) +
#     ylab("Predicted demersal catch") +
#     geom_smooth(alpha = 0.75, size = 2, show.legend = FALSE) +
#     theme_classic()
```

# Spatial plots
```{r}
full_dat %<>% mutate(ID = row_number()) 
sp_dat %<>% mutate(ID = row_number()) 

sp_dat %<>% left_join(full_dat[, c("ID","p_dem.fit", "p_dem.se.fit")], by = "ID")

sp_grid <- sp_dat %>% distinct(gridID_alt, .keep_all = TRUE) %>% 
  st_as_sf()

ggplot() +
  geom_sf(data = sp_grid$x, aes(fill = sp_grid$p_dem.fit), lwd = 0.05) +
  scale_fill_gradient(name = "Demersal Catch") +
  theme_classic()

ggplot() +
  geom_sf(data = sp_grid$x, aes(fill = sp_grid$p_dem.se.fit), lwd = 0.05) +
  scale_fill_gradient(name = "Error: Demersal Catch") +
  theme_classic()

ggplot() +
  geom_sf(data = sp_grid$x)

ggplot() +
  geom_histogram(data = full_dat, aes(x = p_dem.fit))
```

