This script creates a grid with associated attributes from a ASC RUM. 

# Set up
```{r setup}
rm(list = ls())

    # knitr options
    knitr::opts_chunk$set(warning = FALSE, message = TRUE, echo = FALSE, fig.align =
                            'center', fig.width = 10, fig.height = 7) 
    
    # libraries 
    library(tidyverse)
    library(dplyr)
    library(ggplot2)
    library(sp)
    library(raster)
    library(rgeos)
    library(rgdal)
    library(sf)
    library(lwgeom)
    library(googledrive)
    library(units)
    library(nngeo)
    library(magrittr)
    library(todor)
    library(mgcv)
    library(sfnetworks)
    library(ggmap)
    # remotes::install_github("jlacko/gmapsdistance")
    library(gmapsdistance)
    library(janitor)
    
    

    # data
    # BR <- st_read("./data/shp/natBR.shp") # boat ramps
    BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") %>% # from BRtrips.R
      st_transform(crs = 4283 )%>% st_make_valid()
    
    # npz <- st_read("./data/gpkg/wha_ntz_no_shore_fishing.gpkg") %>% 
    #   st_transform(crs = 4283) %>% st_make_valid()
    
    # npz <- st_read("./data/gpkg/ntz.gpkg") %>%
    #   st_transform(crs = 4283) %>% st_make_valid()
    
    grid_base <- st_read("./data/gpkg/ascBase_v4.gpkg") %>%
    st_transform(crs = 4283) %>% st_make_valid()
    
    sh_asc_base <- st_read("./data/gpkg/sh_asc_base.gpkg") %>% 
      st_transform(crs = 4283)
    
     s_ex_cent <- st_read("./data/gpkg/s_ex_centroids.gpkg") %>% 
      st_transform(crs = 4283)
     
     s_nex_buff <- st_read("./data/gpkg/s_nex_buff.gpkg") %>% 
      st_transform(crs = 4283)
    
     s_nex_cent <- st_read("./data/gpkg/s_nex_cent.gpkg") %>% 
      st_transform(crs = 4283)
     
    accom <- st_read("./data/gpkg/ning_accom.gpkg") %>% 
      st_transform(crs = 4283)
    
    dat <- read_csv("data/01_data/1.2_dat.csv")
    
    # bathy <- raster("./data/raster/NWSbathy.tif") # bathy
    
    coast <- st_read("./data/gpkg/coast.gpkg") %>%
      st_transform(crs = 4283) %>%
      dplyr::select(geom) %>%
      st_make_valid()
    
    sc_split <- st_read("./data/gpkg/ncmpSplit.gpkg") %>%
      st_transform(crs = 4283) %>%
      dplyr::select(geom) %>%
      st_make_valid()
    
    
    hol <- read_csv("./data/RAW/Holidays.csv") %>% 
      mutate(Date = as.Date(Date, format = "%d/%m/%y"))

    # consump <- read.csv("./data/RAW/consump.csv")
    
    boat_perf <- read.csv("./data/RAW/boatengines.csv")
    
    vott <- read.csv("./data/RAW/VOTT.csv")
    
    # habitat <- st_read("./data/gpkg/ning_hab.gpkg") %>% 
    #   st_transform(crs = 4283) %>% 
    #   st_make_valid() %>% 
    #   mutate(habitat = tolower(habitat))
    
    # gulf <- st_read("./data/gpkg/exgulf.gpkg") %>% 
    #   st_transform(crs = 4283)
    # 
    #  tant <- st_read("./data/gpkg/launch_areas.gpkg") %>% 
    #   st_transform(crs = 4283)
      # 
      #     CB <- st_read("./data/gpkg/CB_launch.gpkg") %>% 
      # st_transform(crs = 4283)
      # 
    # get fuel csv from here
    # https://www.fuelwatch.wa.gov.au/retail/monthly
    # need to resave as proper csv format
    # jan - apr 2023
    fuel <- read_csv("./data/RAW/Monthly-ULP-prices-Gascoyne-201507-202109.csv")
    
    # models
    cons_mod <- readRDS("./models/cons_mod.rda")
    sp_mod <- readRDS("./models/sp_mod.rda")
    bl_mod <- readRDS("./models/bl_mod.rda")
    
    # simulation
    sim_name <- "sim4"       #'[#NOTE: check simulation name]
    # 
    # sim <- st_read(paste0("./data/gpkg/sims/asc_", sim_name, ".gpkg")) %>% 
    #   st_transform(crs = 4283)
    
    sim <- st_read(paste0("./data/gpkg/sim4_v2.gpkg")) %>% 
      st_transform(crs = 4283) %>% st_make_valid()
    
    # functions
    # source("./functions/spatialFunc.R") # spatial functions
    # source("./functions/ascFunc.R") # function to make asc grid
    
    sf_use_s2(FALSE)
    
    # ggplot()+
    #   geom_sf(data = grid_base) +
    #   geom_sf(data = sim, fill = "green") +
    #    geom_sf(data = npz, fill = "blue")
   
    
    #### FUNCTION 
  # depth range function originally from spatial func
depth_range <- function(bathy, polygon){
  poly_crs <- crs(polygon) # store polygons original crs
  bathy_crs <- crs(bathy)  # store raster crs
  poly_to_bathy_crs <- st_transform(polygon, bathy_crs) # re-project polygon to match raster
  r.vals <- raster::extract(bathy, poly_to_bathy_crs) #extract values of raster
  r.min <- unlist(lapply(r.vals, FUN = min)) #take mean for each polygon
  r.max <- unlist(lapply(r.vals, FUN = max)) #take mean for each polygon
  poly_to_bathy_crs$depth_range <- r.max - r.min #merge mean back in to polygon
  polygon <- st_transform(poly_to_bathy_crs, poly_crs)
}

st_centroid_within_poly <- function (poly) {

  # check if centroid is in polygon
  centroid <- poly %>% st_centroid()
  in_poly <- st_within(centroid, poly, sparse = F)[[1]]

  # if it is, return that centroid
  if (in_poly) return(centroid)

  # if not, calculate a point on the surface and return that
  centroid_in_poly <- st_point_on_surface(poly)
  return(centroid_in_poly)
}

dist <- function(centroid_geom, br_geom, RampID, gridid) {
  
  # Calculate non-linear distance 
  
  # extract coordinates
  br <- as.data.frame(st_coordinates(br_geom))
  points <- as.data.frame(st_coordinates(centroid_geom)) 
  
  NGRIDS <- nrow(points) # extract number of grids
  ids <- c(RampID, gridid) # make ids
  
  points <- rbind(br, points) %>% mutate(ID = row_number()) # first obs are the boat ramps
  
  NCELL <- nrow(points) # Set the number of cells in the model
  
  ## Convert the points in the centroids of the polygon to a spatial points file
  points$ID <- as.integer(points$ID)
  points_sf <- st_as_sf(points, coords = c("X", "Y"))
  points_sp <- st_cast(st_geometry(points_sf), "POINT")
  
  ## Figure out which six points are the closest - won't all have six close ones but can start from there
  dist.mat <- st_distance(points_sp) # Great Circle distance since in lat/long
  
  ## Get the IDS for the cells that are neighbours
  n.closest <- 6 # Decide how many neighbours you want to use
  
  neighbours <- as.data.frame(array(0, dim = c(NCELL, n.closest)))
  
  for (i in 1:n.closest) {
    neighbours[,i] <- apply(dist.mat, 1, function(x) { order(x, decreasing = F)[i + 1] })
  }
  
  ## Give the neighbouring points geometry based on the original set of points
  point.list <- list()
  
  for (i in 1:n.closest) {
    
    temp1 <- as.data.frame(neighbours[,i])
    
    temp2 <- temp1 %>%
      rename(ID = "neighbours[, i]") %>% 
      inner_join(., points, by = "ID") %>% 
      st_as_sf(., coords = c("X", "Y")) 
    
    temp3 <- st_cast(st_geometry(temp2), "POINT")
    
    point.list[[i]] <- temp3
    
  }
  
  # CONNECT THE POINTS TO THEIR NEIGHBOURS TO FORM A NETWORK ####
  n <- nrow(points)
  
  ## Form linestrings and then multilinestrings
  multilinestrings <- list()
  
  for (i in 1:n.closest) {
    
    linestring <- point.list[[i]]
    
    temp <- lapply(X = 1:n, FUN = function(x) {
      pair <- st_combine(c(points_sp[x], linestring[x]))
      line <- st_cast(pair, "LINESTRING")
      return(line)
    })
    
    temp2 <- st_multilinestring(do.call("rbind", temp))
    
    multilinestrings[[i]] <- temp2
    
  }
  
  connected <- st_combine(c(multilinestrings[[1]], multilinestrings[[2]], multilinestrings[[3]],   multilinestrings[[4]], multilinestrings[[5]], multilinestrings[[6]]))
  connected <- st_cast(connected, "LINESTRING") # Needs to be a line string rather than multiline for the next step
  
  # setwd(working.dir)
  # st_write(connected, paste0(model.name, sep="_", "network.shapefile.shp"))
  
  # SET UP THE SF NETWORK AND CREATE FULL DISTANCE MATRIX ####
  network <- as_sfnetwork(connected, directed = FALSE) %>%
    activate("edges") %>%
    mutate(weight = edge_length())
  
  ## Calculate the distances from each point to every other point on the network
  net <- activate(network, "nodes")
  network_matrix <- st_network_cost(net, from = points_sf, to = points_sf)
  network_matrix <- network_matrix * 111 # Multiple by 111 to get from degrees to kms
  dim(network_matrix) # Check that the dimensions match up to how many points you think you should have in the network
  
  ## Checks to make sure it's done what you want
  # Checking that short distances between points are the same e.g. 1 -> 2
  # test <- st_distance(points_sf[1,2], points_sf[2,2])
  # test * 111 # 8.2km 
  # network_matrix[1,2] # 8.2km km 
  # 
  # # Checking that points that cross the land are not the same - should be longer in our network matrix
  # # Find two points that are either side of the land and should have a long distances between them
  # plot(points_sf, col = ifelse(points_sf$ID == 1300 | points_sf$ID == 600, "red", "black")) # These are on opposite sides of the cape
  # 
  # test <- st_distance(points_sf[1300,2], points_sf[600,2])
  # test*111 # 115km
  # 
  # test_matrix <- st_network_cost(net, from = points_sf[1300, 2], to = points_sf[600,2])
  # test_matrix*111 # 131km
  
  colnames(network_matrix) <- ids # change names to ids
  
  nbr <- nrow(br) + 1 # set gather limit
  
  # remove boat ramps, append gridIDs and gather data frame
  network_matrix %<>% 
    as.data.frame() %>% 
    dplyr::select(1:4) %>% 
    slice(nbr:nrow(.)) %>% 
    mutate(gridid = gridid) %>% 
    gather("RampID", "nl_km_br", 1:length(.) - 1) %>% 
    mutate(nl_km_br = round(nl_km_br, 2))
  
  # nrow(dist) == nrow(grid)
  
  # Calculate linear distance
  l_dist <- as.data.frame(set_units(st_distance(centroid_geom, br_geom), km))
  l_dist %<>% gather("RampID", "l_km_br", 1:length(.)) %>% 
    mutate(l_km_br = round(as.numeric(l_km_br), 2))
  
  # append linear distance
  network_matrix$l_km_br <- l_dist$l_km_br
  
  return(network_matrix)
}

# snap points to line
st_snap_points = function(x, y, max_dist = 1000) {

  if (inherits(x, "sf")) n = nrow(x)
  if (inherits(x, "sfc")) n = length(x)

  out = do.call(c,
                lapply(seq(n), function(i) {
                  nrst = st_nearest_points(st_geometry(x)[i], y)
                  nrst_len = st_length(nrst)
                  nrst_mn = which.min(nrst_len)
                  if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
                  return(st_cast(nrst[nrst_mn], "POINT")[2])
                })
  )
  return(out)
}
```

# Joining external data
## Fuel
```{r}
fuel %<>%
  mutate(TripMonth = gsub("[^a-zA-Z]", "", Month)) %>%
  mutate(season = ifelse(TripMonth %in% c("Sep", "Oct"), "Spring", 
                           ifelse(TripMonth %in% c("Jul", "Aug"), "Winter",
                                  "Autumn"))) %>% 
  mutate(numYear = as.numeric(paste0("20", as.numeric(gsub("[^0-9]", "", Month))))) %>%
  mutate(cost = Average/100)

dat %<>% left_join(fuel[, c("TripMonth", "numYear", "cost")])

rm(fuel)
```

## Boat length
Predicting as a function of party size to fill NAs
```{r}
# dat %<>% rename(PartySize = Party)
# tmp <- dat %>% filter(is.na(BoatLength) & SiteType == "Boat") %>% dplyr::select(TripID, BoatLength, PartySize)
# # unique(tmp$Party)
# 
# # Filling Party size where it exists
# tmp %<>% mutate(PartySize = ifelse(PartySize %in% c("6f", "Two couples 2 kids", "3F, 2M, 1b"), 6, 
#                                     ifelse(PartySize %in% c("2f", "2 dudes", "2males", "Couple", "1M 1b"), 2, 
#                                            ifelse(PartySize %in% c("2f, 2kids", "4 friends", "2 couples", "4 mates", "1m1b", "Couple, 2g", "Couple,2g 1b"), 4,
#                                                   ifelse(PartySize %in% c("Man", "1M"), 1, 
#                                                          ifelse(PartySize %in% c("2b1g", "3M", "3m"), 3, NA))))))
# 
#       tmp$lm_bl <- predict(bl_mod, tmp) # predicting boatlength using party size
#       tmp$lm_bl <- round(as.numeric(tmp$lm_bl), 2)
#       dat %<>%  left_join(tmp[, c("TripID", "lm_bl")])
#       
#       dat %<>% 
#         mutate(BoatLength = ifelse(SiteType == "Boat" & !is.na(lm_bl), lm_bl, BoatLength)) %>% # appending modelled boat length
#         mutate(BoatLength = ifelse(SiteType == "Boat" & is.na(BoatLength), mean(BoatLength, na.rm = T), BoatLength)) # filling rest of boat length with NAs
```

## VOTT
```{r}
# VOTT 
    dat %<>% left_join(vott[, c("Postcode", "ann_inc_21", "VOTT_21")]) 

    tmp <- dat %>% filter(!is.na(ann_inc_21) & !is.na(BoatLength)) %>% mutate(ann_inc_21 = as.numeric(ann_inc_21))

    lm_ann_inc <- lm(ann_inc_21 ~ BoatLength, data = tmp)
    

      # ggplot(dat = tmp, aes(x = ann_inc_21, y = BoatLength)) +
      #   geom_point() +
      #   stat_smooth(method = "lm")
      
      dat$lm_ann_inc <- predict(lm_ann_inc, dat)
      
      # mean(vott$ann_inc_21, na.rm = T) - mean(vott$ann_inc_16, na.rm = T)
      
      dat %<>%
        mutate(ann_inc = ifelse(!is.na(ann_inc_21), ann_inc_21, lm_ann_inc)) %>% 
        mutate(ann_inc = ifelse(is.na(ann_inc), mean(ann_inc, na.rm = T), ann_inc)) %>% 
        mutate(VOTT = round((ann_inc/(38*52))/3, 2))
      
      rm(vott)
```

## Boat specs
```{r}
# Consumption
boat_perf %<>%  
  filter(kmperh < 4000) %>% 
    mutate(boat_size2L = ifelse(boatlength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(boatlength <= 3.75, "S", 
                            ifelse(boatlength <= 6.75, "M", "L"))) %>% 
  mutate(cons = kmperl/nEngines)

boat3L <- boat_perf %>% 
  group_by(boat_size3L) %>% 
  summarise(sp3l = median(kmperh),
            cons3l = median(cons))

boat2L <- boat_perf %>% 
  group_by(boat_size2L) %>% 
  summarise(sp2l = median(kmperh),
            cons2l = median(cons))
  
dat %<>% 
  mutate(BoatLength = ifelse(is.na(BoatLength), mean(BoatLength, na.rm = TRUE), BoatLength)) %>%
  mutate(boat_size2L = ifelse(BoatLength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(BoatLength <= 3.75, "S", 
                            ifelse(BoatLength <= 6.75, "M", "L")))  %>% 
  left_join(boat2L[, c("boat_size2L", "cons2l", "sp2l")], by = "boat_size2L") %>% 
  left_join(boat3L[, c("boat_size3L", "cons3l", "sp3l")], by = "boat_size3L")

dat %<>% 
  mutate(cons_flt = median(boat_perf$cons)) %>% 
  mutate(sp_flt = median(boat_perf$kmperh))

# modeled consumption
 temp <- dat %>% 
        dplyr::select(BoatLength) %>% 
        rename(boatlength = BoatLength) %>% 
        st_drop_geometry()
      
      gam_cons <- predict(cons_mod, temp)
      gam_sp <- predict(sp_mod, temp)
      
      dat$gam_cons <- as.numeric(gam_cons)
      dat$gam_sp <- as.numeric(gam_sp)


rm(boat2L, boat3L, temp, gam_cons, sp_cons, cons_mod, tmp, bl_mod, lm_ann_inc, boat_perf, gam_sp)
```

# Filtering
All data filters have to be done before making the choice set.
```{r}
dat %<>% 
  filter(facYear > 2020) %>% 
  mutate(Activity = ifelse(Activity %in% c("Diving", "Snorkeling", "Shark cleaning", "Megafauna"), "Wildlife", Activity)) %>% 
  mutate(Activity = ifelse(Activity %in% c("Explore", "JetSki"), "Other", Activity)) %>% 
  mutate(FishingType = ifelse(ActivityType %in% "Both", NA, FishingType)) %>% 
  mutate(ActivityType = ifelse(ActivityType %in% "Both", "Non-Extractive", ActivityType)) %>% 
  mutate(FishingType = ifelse(FishingType %in% "Casting" & SiteType %in% "Boat" | FishingType %in% "Squidding", "Nearshore", FishingType)) %>% 
  mutate(FishingType = ifelse(FishingType %in% "Demersal" & SiteType %in% "Shore", "Casting", FishingType)) %>% 
  mutate(FishingType = ifelse(is.na(FishingType) & SiteType %in% "Shore" & ActivityType %in% "Extractive", "Casting", FishingType)) %>% 
  filter(!(Activity %in% "Other"))  %>% 
  filter(!(Activity %in% "Fishing") & ActivityType %in% "Non-Extractive" | ActivityType %in% "Extractive") %>% 
  mutate(Activity = ifelse(Activity %in% "Fishing", FishingType, Activity))

    dat %<>% 
        filter(!is.na(UseLat), !is.na(UseLong)) %>% # filtering empty coords
      st_as_sf(coords = c("UseLong", "UseLat"), crs = 4283)  %>% ## make sf object
      mutate(dem_only = ifelse(Dem_bin == 1 & Pel_bin == 0 & nrSh_bin == 0 & Mol_bin == 0 &
                                 Crust_bin == 0, 1, 0)) 

      # filter(ActivityType == "Extractive") %>% # filtering activity
      # filter(FishingType %in% c("Demersal", "Casting")) %>% # fishing RUM
      # filter(SiteType %in% "Boat") %>% # filtering activity
      # filter(str_detect(Site, "BR"))
      
    # need one trip per row (longest site visited on trip)
    dat %<>% 
      group_by(PersonID, TripID) %>% 
      slice(which.max(decDuration)) %>% 
      ungroup() 
    
      dat <- st_crop(dat, grid_base) # removing outliers 
    
      #'[#VALIDATE: TRUE, no duplicated trip IDs)]
      identical((which(duplicated(dat$TripID) == TRUE)), integer(0)) == TRUE
      
    dat %<>% 
      mutate(UseLong = st_coordinates(geometry)[,1]) %>%
      mutate(UseLat = st_coordinates(geometry)[,2]) 
    
    
    dat %<>% mutate(Age = ifelse(is.na(Age), mean(dat$Age, na.rm = TRUE), Age))
    dat %<>% mutate(exTimes12m = ifelse(is.na(exTimes12m), mean(dat$exTimes12m, na.rm = TRUE), exTimes12m))
    dat %<>% mutate(Resident = ifelse(Resident %in% "Yes", 1, 0))
    
      write.csv(dat, "data/02_data/2.1_filtered_dat.csv")
      
      rm(hol, grid_base)
```

## Accomodation 

```{r}
# aggregate accomodation
dat %<>% 
  mutate(Accom = ifelse(Resident %in% "Yes" & Postcode == 6707, "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Resident %in% "Yes" & Postcode == 6701, "CoralBay", Accom)) %>% 
  mutate(Accom = ifelse(is.na(Accom) & UseLat < -22.5, "CoralBay", Accom)) %>% 
  mutate(Accom = ifelse(is.na(Accom) & UseLat > -22.5, "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Accom %in% c("ExmouthEscape", "RACHolPark", "MantaResort", "Potshot", "ExmouthVillas", "NingalooBreeze", "NingalooLodge", "OspreyHolVillage"), "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Accom %in% c("BayView", "PeoplesPark"), "CoralBay", Accom))

# rename accom geometry
accom %<>%
  rename(geom_accom = geom) %>% as.data.frame() 

dat %<>% left_join(accom) # appen accom geom to dat

rm(accom)
```


# Weighting
Following protocol outed in KAP

## Step 5.1: Identify starta to be weighted
  - boat ramp (no others necessary because on intensive field trip)
  
The primary sampling unit (psuid) is a shift am/pm at a specific boat ramp on a specific date where at least one survey was conducted
```{r}
## Prepping data 
tot_smpl <- nrow(dat) # total samples

# Append frequency of each starta to data set
br_freq <- table(dat$Site) %>% as.data.frame() %>% rename(br_freq = Freq)

dat %<>% left_join(br_freq, by = c("Site" = "Var1"))
```

## Step 5.2: Calculate inclusion probability
```{r}
# Step 5.2a: calulate inclusion probability
dat %<>%
  mutate(br_inprob = br_freq/tot_smpl)
```

## Step 5.3: Calculate IPW
```{r}
dat %<>% mutate(ipw = 1/br_inprob)

rm(br_freq, tot_smpl)

a <- dat %>% distinct(Site, .keep_all = TRUE)

a[, c("Site", "ipw")]
```

# Grids
## b_ex
### Make grid
```{r}
b_ex_dat <- dat %>% filter(ActivityType %in% "Extractive" & SiteType %in% "Boat" & str_detect(Site, "BR"))
# # 
# b_ex <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = b_ex_dat, from = 0.03, 
#                 by = 0.02, crs = 4283, vert = FALSE)
# 
# 
# b_ex %<>% st_transform(crs = 4283) %>% st_cast("MULTIPOLYGON")
# 
# st_write(b_ex, paste0("./data/gpkg/sims/2.1_asc_manual_edit_", g1, "_", sim_name, "_4283.gpkg"), append = FALSE) # need to write with st_write to open in QGISRUMs

   b_ex <- st_read(paste0("./data/gpkg/","b_ex_grid_", sim_name, "_qgis.gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
   
ggplot()+
  geom_sf(data = b_ex_dat, aes(colour = Site))
```

### Atrributes
```{r}
# RAMPS
b_ex_dat %<>%
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR"), "Bundegi", NA)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("ExmouthBR"), "Exmouth", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("TantabiddiBR"), "Tantabiddi", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("CoralBayBR"), "Coral Bay", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(is.na(Site), "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR", "ExmouthBR") & UseLong < 114, "Tantabiddi", Ramp_name))
  
ggplot()+
  geom_sf(data = b_ex_dat, aes(colour = Ramp_name))

# IDs
## remove wrong id col made by function
    b_ex %<>% dplyr::select(-contains("gridID_"))

## Make new gridid_alt col
    b_ex %<>% mutate(gridid_alt = paste("b_ex", row_number(), sep = "_"))

## make binary gridid_col
    for (i in unique(b_ex$gridid_alt)) {
    gridid = ifelse(b_ex$gridid_alt == i, 1, 0)
    b_ex[,length(b_ex) + 1] <- gridid
    colnames(b_ex)[ncol(b_ex)] <- paste0("gridid_", i)
  }

# AREA
# needs redone after manual manipulation
    b_ex$area <- as.numeric(round(set_units(st_area(b_ex), km^2), 2))
    
    # USE COUNT
# needs redone after manual manipulation   
    b_ex$use_count <- lengths(st_intersects(b_ex, b_ex_dat))
    
  ggplot() +
    geom_sf(data = b_ex, aes(fill = as.factor(use_count)))

# CENTROID   
    centroid <- st_centroid_within_poly(b_ex) # gets centroid of every grid cell
    b_ex$centroid <- centroid$geom # append centroid to grid 
 # checking centroids are correct
  ggplot() +
    geom_sf(data = b_ex) +
      geom_sf(data = b_ex$centroid, size = 0.5, colour = "red") + theme_classic()
    
  
  b_ex %<>% filter(!(gridid_alt %in% "b_ex_48"))  # empty
  
## NON-LINEAR DISTANCE FROM BR TO CENTROID
  # create distance matrix from every ramp to every grid
  b_ex_dist <- dist(b_ex$centroid, BRtrips$geometry, BRtrips$RampID, b_ex$gridid_alt) # create distance dataframe
  
b_ex_dist %<>%
  rename(gridid_alt = gridid) %>% 
  group_by(gridid_alt) %>%
  mutate(min_nl_km_br = ifelse(nl_km_br == min(nl_km_br), 1, 0)) %>% 
  arrange(gridid_alt) %>% 
  ungroup() %>% 
  filter(min_nl_km_br == 1)

  b_ex %<>% left_join(b_ex_dist, by = "gridid_alt") # appending to grid
  
  nrow(b_ex) == n_distinct(b_ex$gridid_alt)*nrow(BRtrips) # check dataset is the correct size - this is if you want t keep all te BRS
  

  ## GRID GEOMETRIES
  
  b_ex %<>% 
    rename(geom_asc = geom,
                   geom_cent = centroid)
    
  # 
  BRtrips %<>% ## Appending BRtrips
    rename(geom_br = geometry) %>%
    as.data.frame() %>%
    mutate(RampID = as.character(RampID))
  
  b_ex %<>% left_join(BRtrips, by = "RampID") # appending to grid
  
# check all geometries work
  ggplot() +
    geom_sf(data = b_ex$geom_asc) +
    geom_sf(data = b_ex$geom_cent, colour = "red") +
    geom_sf(data = b_ex$geom_br, colour= "blue")
  
## checking distances
    ggplot(b_ex) +
      geom_sf(aes(geometry = geom_asc, fill = nl_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Non-linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    ggplot(b_ex) +
      geom_sf(aes(geometry = geom_asc, fill = l_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    # REMOVE INVALID CELLS
##'[#NOTE:Check empty grids before removing]
    
  # Remove current sz and cells with no data presnet
    b_ex %<>% filter(sz_current == 0 & use_count != 0)

  # plot should have no zeros and check data to make sure
    ggplot() +
      geom_sf(data = b_ex, aes(fill = as.factor(use_count))) +
      geom_sf(data = b_ex_dat, size = 0.05)
    
            # isolating grid ID to append to dat
    b_ex_grid <- b_ex %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    b_ex_dat %<>% 
      st_join(b_ex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
    b_ex_dat %<>% filter(!is.na(gridid_vis)) # removes people not in grid e.g. fishing in sz
    
    ggplot() +
      geom_sf(data = b_ex, aes(fill = as.factor(sz))) +
      geom_sf(data = b_ex_dat, size = 0.5)
    
  ## offshore/inshore vraiable
   # b_ex$inshore <- st_intersects(b_ex, sc_split, sparse = FALSE) # this didnt work so dooing really hacky way until i have time to do it properly
   # 
     ggplot()+
     geom_sf(data = b_ex, aes(fill = gridid_alt))
   # 
    offshore <- b_ex %>% 
     filter(gridid_alt %in% c("b_ex_8", "b_ex_9", "b_ex_10", "b_ex_11", "b_ex_25", "b_ex_12", "b_ex_6", "b_ex_7", "b_ex_56", "b_ex_13", "b_ex_14", "b_ex_15", "b_ex_21", "b_ex_29"))
    
   ggplot()+
     geom_sf(data = b_ex) +
     geom_sf(data = offshore, fill = "red")
   
    b_ex %<>% mutate(offshore = ifelse(gridid_alt %in% offshore$gridid_alt, 1, 0))
    
      ggplot()+
     geom_sf(data = b_ex, aes(fill = offshore))
    
    ## EAST/WEST
    ggplot()+
      geom_sf(data = b_ex$geom_asc) +
      geom_sf(data = b_ex$geom_cent) +
      geom_vline(xintercept = 114.17, color = 'red') +# testing line
      geom_hline(yintercept = -22.75, color = 'blue') # testing line
    
    b_ex %<>% 
      mutate(cent_lon = st_coordinates(geom_cent)[,1]) %>%
      mutate(cent_lat = st_coordinates(geom_cent)[,2]) %>%
      mutate(side = ifelse(cent_lon < 114.17, "w", "e")) 
    
    ggplot() +
      geom_sf(data = b_ex$geom_asc, aes(fill = b_ex$side))
    
    b_ex %<>% 
      mutate(br_site = side) %>% 
      mutate(br_site = ifelse(br_site %in% "w", "n_w", br_site)) %>% 
      mutate(br_site = ifelse(cent_lat < -22.75, "s_w", br_site))
    
    ggplot() +
      geom_sf(data = b_ex$geom_asc, aes(fill = b_ex$br_site))
    
```

## b_nex
### Make grid
```{r}
b_nex_dat <- dat %>% filter(ActivityType %in% "Non-Extractive" & SiteType %in% "Boat"& str_detect(Site, "BR"))

# b_nex <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = b_nex_dat, from = 0.03, by = 0.02, crs = 4283, vert = FALSE)
# 
# b_nex %<>% st_transform(crs = 4283) %>% st_cast("MULTIPOLYGON")
# 
# st_write(b_nex, paste0("./data/gpkg/sims/2.1_asc_manual_edit_", g2, "_", sim_name, "_4283.gpkg"), append = FALSE) # need to write with st_write to open in QGISRUMs

   b_nex <- st_read(paste0("./data/gpkg/", "b_nex_grid_", sim_name, "_qgis.gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```

### Attributes
```{r}

# RAMPS
b_nex_dat %<>%
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR"), "Bundegi", NA)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("ExmouthBR"), "Exmouth", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("TantabiddiBR"), "Tantabiddi", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("CoralBayBR"), "Coral Bay", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(is.na(Site), "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% "ExmouthBR" & UseLong < 114, "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% "TantabiddiBR" & UseLat < -22.11, "Exmouth", Ramp_name))

ggplot()+
  geom_sf(data = b_nex_dat, aes(colour = Ramp_name))

# IDs
## remove wrong id col made by function
    b_nex %<>% dplyr::select(-contains("gridID_"))

## Make new gridid_alt col
    b_nex %<>% mutate(gridid_alt = paste("b_nex", row_number(), sep = "_"))

## make binary gridid_col
    for (i in unique(b_nex$gridid_alt)) {
    gridid = ifelse(b_nex$gridid_alt == i, 1, 0)
    b_nex[,length(b_nex) + 1] <- gridid
    colnames(b_nex)[ncol(b_nex)] <- paste0("gridid_", i)
  }

# AREA
# needs redone after manual manipulation
    b_nex$area <- as.numeric(round(set_units(st_area(b_nex), km^2), 2))
    
# USE COUNT
# needs redone after manual manipulation   
    b_nex$use_count <- lengths(st_intersects(b_nex, b_nex_dat))

# CENTROID   
    centroid <- st_centroid_within_poly(b_nex) # gets centroid of every grid cell
    b_nex$centroid <- centroid$geom # append centroid to grid 
 # checking centroids are correct
  ggplot() +
    geom_sf(data = b_nex$geom) +
    geom_sf(data = b_nex$centroid, size = 0.5, colour = "red") + theme_classic()
  
## NON-LINEAR DISTANCE FROM BR TO CENTROID
  # create distance matrix
  b_nex_dist <- dist(b_nex$centroid, BRtrips$geom_br, BRtrips$RampID, b_nex$gridid_alt) # create distance dataframe
  
  b_nex_dist %<>%
  rename(gridid_alt = gridid) %>% 
  group_by(gridid_alt) %>%
  mutate(min_nl_km_br = ifelse(nl_km_br == min(nl_km_br), 1, 0)) %>% 
  arrange(gridid_alt) %>% 
  ungroup() %>% 
  filter(min_nl_km_br == 1)

  b_nex %<>% left_join(b_nex_dist, by = "gridid_alt") # appending to grid
  
  nrow(b_nex) == n_distinct(b_nex$gridid_alt)*nrow(BRtrips) # check dataset is the correct size
  

  ## GRID GEOMETRIES
  
  b_nex %<>% 
    rename(geom_asc = geom,
                   geom_cent = centroid) %>%
    mutate(RampID = as.character(RampID))
  
  b_nex %<>% left_join(BRtrips, by = "RampID") # appending to grid
  
# check all geometries work
  ggplot() +
    geom_sf(data = b_nex$geom_asc) +
    geom_sf(data = b_nex$geom_cent, colour = "red") +
    geom_sf(data = b_nex$geom_br, colour= "blue")
  
## checking distances
    ggplot(b_nex) +
      geom_sf(aes(geometry = geom_asc, fill = nl_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Non-linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    ggplot(b_nex) +
      geom_sf(aes(geometry = geom_asc, fill = l_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    # REMOVE INVALID CELLS
##'[#NOTE:Check empty grids before removing]  
     
  # Remove current sz and cells with no data presnet
    b_nex %<>% filter(use_count != 0)
    
      # plot should have no zeros and check data to make sure
    ggplot() +
      geom_sf(data = b_nex, aes(fill = as.factor(use_count)))+
      geom_sf(data = b_nex_dat)
    
            # isolating grid ID to append to dat
    b_nex_grid <- b_nex %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    b_nex_dat %<>% 
      st_join(b_nex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
    ggplot() +
      geom_sf(data = b_nex, aes(fill = as.factor(sz))) +
      geom_sf(data = b_nex_dat, size = 0.5)
      ## offshore/inshore vraiable
   # b_ex$inshore <- st_intersects(b_ex, sc_split, sparse = FALSE) # this didnt work so dooing really hacky way until i have time to do it properly
   # 
     ggplot()+
     geom_sf(data = b_nex, aes(fill = gridid_alt))
   
    #  ADDING NEW VARS FOR NET TESTING
     # OFFSHORE
    
     offshore <- b_nex %>%
     filter(gridid_alt %in% c("b_nex_5", "b_nex_15"))
   #  
   ggplot()+
     geom_sf(data = b_nex) +
     geom_sf(data = offshore, fill = "red")
   
    b_nex %<>% mutate(offshore = ifelse(gridid_alt %in% c("b_nex_5", "b_nex_15"), 1, 0))
    
     ggplot()+
     geom_sf(data = b_nex, aes(fill = offshore))
    
    ## EAST/WEST
    ggplot()+
      geom_sf(data = b_nex$geom_asc) +
      geom_sf(data = b_nex$geom_cent) +
      geom_vline(xintercept = 114.17, color = 'red') +# testing line
      geom_hline(yintercept = -22.75, color = 'blue') # testing line
    
    b_nex %<>% 
      mutate(cent_lon = st_coordinates(geom_cent)[,1]) %>%
      mutate(cent_lat = st_coordinates(geom_cent)[,2]) %>%
      mutate(side = ifelse(cent_lon < 114.17, "w", "e")) %>% 
      mutate(side = ifelse(gridid_alt %in% "b_nex_35", "e", side))
    
    ggplot() +
      geom_sf(data = b_nex$geom_asc, aes(fill = b_nex$side))
    
    b_nex %<>% 
      mutate(br_site = side) %>% 
      mutate(br_site = ifelse(br_site %in% "w", "n_w", br_site)) %>% 
      mutate(br_site = ifelse(cent_lat < -22.75, "s_w", br_site))
    
    ggplot() +
      geom_sf(data = b_nex$geom_asc, aes(fill = b_nex$br_site))
```


## s_ex
### Make grids
```{r}
s_ex_dat <- dat %>% filter(ActivityType %in% "Extractive" & SiteType %in% "Shore")
# there is one island based activity that needs removed
# 
# # # check none are actually offshore/island based 
# ggplot() +
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat, colour = "red")
# 
# # filtering out shore activity more than 1 km form shore
s_ex_dat %<>%
  mutate(dist_coast = as.numeric(st_distance(s_ex_dat, sh_asc_base))) %>%
  filter(dist_coast < 1000)
# 
# # check none are actually offshore/island based 
# ggplot()+ 
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat, aes(colour = dist_coast))
#   
# 
# snap_geom <- st_snap_points(s_ex_dat, sh_asc_base)
# 
# snap_geom <- as.data.frame(snap_geom)
# 
# s_ex_dat %<>% 
#       mutate(snap_geom = snap_geom$geometry) 
# 
# ggplot()+ 
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat$snap_geom, colour = "red")
# 
# 
# s_ex_dat %<>%
#   mutate(snap_lon = st_coordinates(snap_geom)[,1]) %>%
#   mutate(snap_lat = st_coordinates(snap_geom)[,2]) 
# 
# write.csv(s_ex_dat, paste0("./data/02_data/2.1_sh_asc_manual_edit_", g3, "_", sim_name, ".csv"), append = FALSE) # need to write with st_write to open in QGISRUMs

# I manually split up the sh_asc_base by sims and sz and remove al tnhat didnt have any point. I took note of the zone and sim_zone for shore fishing

   s_ex_line <- st_read(paste0("./data/gpkg/", "s_ex_grid_", sim_name, ".gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```
### Attributes

s_ex_dat : data
s_ex_line: line
s_ex_buff: polyon buffer
s_ex_cent: centroid of buffer

```{r}
# there are two data points which need to be removed becas ethey are fishing in sz 

    s_ex_line %<>% mutate(gridid_alt = paste("s_ex", row_number(), sep = "_"))

# calculating length
    s_ex_line$length <- as.numeric(round(set_units(st_length(s_ex_line), km), 2))
    
    s_ex_buff <- st_buffer(s_ex_line, 0.007) 
    # s_ex_buff %>% rename(geom_buff = geom) # units in degree 

    for (i in unique(s_ex_buff$gridid_alt)) {
    gridid = ifelse(s_ex_buff$gridid_alt == i, 1, 0)
    s_ex_buff[,length(s_ex_buff) + 1] <- gridid
    colnames(s_ex_buff)[ncol(s_ex_buff)] <- paste0("gridid_", i)
  }

    # make sure that the point in sz which need to be removed are not in buffer
    ggplot() +
      geom_sf(data = s_ex_buff) +
      geom_sf(data = s_ex_dat, size = 0.5)
    
    s_ex_dat %<>% mutate(to_rm = ifelse(st_intersects(s_ex_dat, s_ex_buff), 1, 0)) %>% 
      filter(!is.na(to_rm))
  
  # pDouble check there are no lines, without data and vice versa 
    ggplot() +
      geom_sf(data = s_ex_buff,  aes(colour = zone)) +
        # geom_sf(data = s_ex_dat, size = 0.5)
        geom_sf(data = s_ex_cent, size = 0.5)
    
    # Append centroids to s_ex_buf
     s_ex_cent %<>% 
      rename(geom_cent = geom) %>% # make geom name individual 
       mutate(cent_id = row_number()) # adding id to append to 
       
     s_ex_buff %<>% st_join(s_ex_cent, join = st_intersects) # do st_join
     
    s_ex_cent %<>% as.data.frame() 
  
    s_ex_buff %<>% left_join(s_ex_cent) 
    
     s_ex_buff %<>% 
      rename(geom_asc = geom) # make geoms names individual
     
     ggplot() +
       geom_sf(data = s_ex_buff$geom_asc) + 
       geom_sf(data = s_ex_buff$geom_cent) +
       geom_sf(data = s_ex_dat, colour = "red")
    
    # isolating grid ID to append to dat
     
  s_ex_grid <- s_ex_buff %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    s_ex_dat %<>% 
      st_join(s_ex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
    ggplot()+
      geom_sf(data = s_ex_buff, aes(fill = sim_zone))
    
      ## EAST/WEST
    ggplot()+
      geom_sf(data = s_ex_buff$geom_asc, aes(fill = s_ex_buff$gridid_alt))
    
    s_ex_buff %<>% 
      mutate(side = ifelse(gridid_alt %in% c("s_ex_1", "s_ex_2", "s_ex_3"), "e", "w")) %>% 
      mutate(br_site = side) %>% 
      mutate(br_site = ifelse(br_site %in% "w", "n_w", br_site)) %>% 
      mutate(br_site = ifelse(gridid_alt %in% "s_ex_8", "s_w", br_site))
    
    ggplot() +
      geom_sf(data = s_ex_buff$geom_asc, aes(fill = s_ex_buff$side))
    
    ggplot() +
      geom_sf(data = s_ex_buff$geom_asc, aes(fill = s_ex_buff$br_site))
```

## s_nex
### Make grid
```{r}
s_nex_dat <- dat %>% filter(ActivityType %in% "Non-Extractive" & SiteType %in% "Shore")
# there is one island based activity that needs removed
# 
# # # check none are actually offshore/island based 
# ggplot() +
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat, colour = "red")
# 
# # # filtering out shore activity more than 1 km form shore
s_nex_dat %<>%
  mutate(dist_coast = as.numeric(st_distance(s_nex_dat, sh_asc_base))) %>%
  filter(dist_coast < 1000)
# # 
# # # check none are actually offshore/island based 
# ggplot()+
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat, aes(colour = dist_coast))
# #   
snap_geom <- st_snap_points(s_nex_dat, sh_asc_base)
# # 
snap_geom <- as.data.frame(snap_geom)
# # 
s_nex_dat %<>%
      mutate(snap_geom = snap_geom$geometry)
# # 
# ggplot()+
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat$snap_geom, colour = "red")
# # 
# # 
s_nex_dat %<>%
  mutate(snap_lon = st_coordinates(snap_geom)[,1]) %>%
  mutate(snap_lat = st_coordinates(snap_geom)[,2])

# write.csv(s_nex_dat, paste0("./data/02_data/2.1_sh_asc_manual_edit_", g4, "_", sim_name, ".csv"), append = FALSE) # need to write with st_write to open in QGISRUMs

# I manually split up the sh_asc_base by sims and sz and remove al tnhat didnt have any point. I took note of the zone and sim_zone for shore fishing

   s_nex_line <- st_read(paste0("./data/gpkg/", "s_nex_grid_", sim_name, ".gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```

### Attributes
```{r}
# there are two data points which need to be removed becas ethey are fishing in sz 
    s_nex_buff %<>% mutate(gridid_alt = paste("s_nex", row_number(), sep = "_"))

# calculating length
    # s_nex_line$length <- as.numeric(round(set_units(st_length(s_nex_line), km), 2))

    for (i in unique(s_nex_buff$gridid_alt)) {
    gridid = ifelse(s_nex_buff$gridid_alt == i, 1, 0)
    s_nex_buff[,length(s_nex_buff) + 1] <- gridid
    colnames(s_nex_buff)[ncol(s_nex_buff)] <- paste0("gridid_", i)
  }

    # make sure that the point in sz which need to be removed are not in buffer
    ggplot() +
      geom_sf(data = s_nex_buff) +
      geom_sf(data = s_nex_dat, size = 0.5)
    
    s_nex_dat %<>% mutate(to_rm = ifelse(st_intersects(s_nex_dat, s_nex_buff), 1, 0)) %>% 
      filter(!is.na(to_rm))
  
  # pDouble check there are no lines, without data and vice versa 
    ggplot() +
      geom_sf(data = s_nex_buff,  aes(colour = zone)) +
        # geom_sf(data = s_nex_dat, size = 0.5)
        geom_sf(data = s_nex_cent, size = 0.5)
    
    # Append centroids to s_nex_buf
     s_nex_cent %<>% 
      rename(geom_cent = geom) %>% # make geom name individual 
       mutate(cent_id = row_number()) # adding id to append to 
     
      # there are duplicated geometrys in s_nex_cent
     nrow(s_nex_buff) == nrow(s_nex_cent) # FALSE
     duplicated(s_nex_cent$geom_cent) # TRUE
     
    s_nex_cent %<>% distinct(geom_cent, .keep_all = TRUE)  # keeping only distinct geometries
       
     s_nex_buff %<>% st_join(s_nex_cent, join = st_intersects) # do st_join
     
    s_nex_cent %<>% as.data.frame() 
  
    s_nex_buff %<>% left_join(s_nex_cent) 
    
     s_nex_buff %<>% 
      rename(geom_asc = geom) # make geoms names individual
     
     ggplot() +
       geom_sf(data = s_nex_buff$geom_asc) + 
       geom_sf(data = s_nex_buff$geom_cent) 
       # geom_sf(data = s_nex_dat, colour = "red")
       
       # calculate length
       c <- s_nex_buff %>% st_cast("MULTILINESTRING")
      c <- st_intersection(c, coast)
      c$length <- as.numeric(round(set_units(st_length(c), km), 2))
       
       ggplot()+
         geom_sf(data = c, aes(colour = as.factor(length)))
       
       c %<>% as.data.frame() %>% dplyr::select(gridid_alt, length) %>% st_drop_geometry()
       
       s_nex_buff %<>% left_join(c) #
       
    # isolating grid ID to append to dat
     
  s_nex_grid <- s_nex_buff %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    s_nex_dat %<>% 
      st_join(s_nex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
      ggplot()+
      geom_sf(data = s_nex_buff, aes(fill = sim_zone))
      
      
      ## EAST?WEST
    ggplot()+
      geom_sf(data = s_nex_buff$geom_asc, aes(fill = s_nex_buff$gridid_alt))
    
    s_nex_buff %<>% 
      mutate(side = ifelse(gridid_alt %in% c("s_nex_1", "s_nex_2", "s_nex_3", "s_nex_4", "s_nex_5", "s_nex_6"), "e", "w")) %>% 
      mutate(br_site = side) %>% 
      mutate(br_site = ifelse(br_site %in% "w", "n_w", br_site)) %>% 
      mutate(br_site = ifelse(gridid_alt %in% c("s_nex_16", "s_nex_19", "s_nex_18", "s_nex_17"), "s_w", br_site))
    
    ggplot() +
      geom_sf(data = s_nex_buff$geom_asc, aes(fill = s_nex_buff$side))
    
    ggplot() +
      geom_sf(data = s_nex_buff$geom_asc, aes(fill = s_nex_buff$br_site))
    
    rm(b_ex_dist, b_ex_grid, c, centroid, coast, s_ex_cent, s_ex_grid, s_ex_line, s_nex_cent, s_nex_grid, s_nex_line, sh_asc_base, snap_geom, gridid, i, depth_range, dist, st_centroid_within_poly, st_snap_points, b_nex_dist, b_nex_grid)
```


## Expand data
### Full choice set
```{r}
# make data frames
b_ex_df <- as.data.frame(b_ex)
b_nex_df <- as.data.frame(b_nex)
s_ex_df <-  as.data.frame(s_ex_buff)
s_nex_df <-  as.data.frame(s_nex_buff)

# join
b_opts <- full_join(b_ex_df, b_nex_df) # boat based choice options
s_opts <- full_join(s_ex_df, s_nex_df) # shore base choice options

# test joins
nrow(b_ex_df) + nrow(b_nex_df) == nrow(b_opts)
nrow(s_ex_df) + nrow(s_nex_df) == nrow(s_opts)

# join shore and boat options to get full choice set
cset <- full_join(b_opts, s_opts)

nrow(b_opts) + nrow(s_opts) == nrow(cset)

# make stata friendly
cset %<>% clean_names() 
```

### Full data set
```{r}
# Make data stata friendly
    b_ex_dat %<>% clean_names()
    b_nex_dat %<>% clean_names()
    s_ex_dat %<>% clean_names()
    s_nex_dat %<>% clean_names()
    
    # select vars you need -> mandatory: TripID, PersonID, gridID_vis, Site, BoatLength  
    b_ex_dat %<>% 
      dplyr::select(trip_id, person_id, gridid_vis, ramp_name, ipw, cost, ipw, boat_access,
                    cons_flt, sp_flt, cons2l, sp2l, cons3l, sp3l, gam_cons, gam_sp, vott, ann_inc, age,
                    ex_times12m, resident, accom, geom_accom, geometry, use_long, use_lat) %>%
      distinct() %>% 
      as.data.frame()
    
      
    b_nex_dat %<>% 
      dplyr::select(trip_id, person_id, gridid_vis, ramp_name, ipw, cost, ipw, boat_access,
                    cons_flt, sp_flt, cons2l, sp2l, cons3l, sp3l, gam_cons, gam_sp, vott, ann_inc, age,
                    ex_times12m, resident,accom, geom_accom, geometry, use_long, use_lat) %>%
      distinct() %>% 
      as.data.frame()
        
    s_ex_dat %<>% 
      dplyr::select(trip_id, person_id, gridid_vis, ipw, cost, ipw, boat_access,
                    cons_flt, sp_flt, cons2l, sp2l, cons3l, sp3l, gam_cons, gam_sp, vott, ann_inc, age,
                    ex_times12m, resident,accom, geom_accom, geometry, use_long, use_lat) %>%
      distinct() %>% 
      as.data.frame()
            
    s_nex_dat %<>% 
      dplyr::select(trip_id, person_id, gridid_vis, ipw, cost, ipw, boat_access,
                    cons_flt, sp_flt, cons2l, sp2l, cons3l, sp3l, gam_cons, gam_sp, vott, ann_inc, age,
                    ex_times12m, resident,accom, geom_accom, geometry, use_long, use_lat) %>%
      distinct() %>% 
      as.data.frame()
    
    #'[#VALIDATE: TRUE, there are no unassigned gridIDs]
    
    identical((which(is.na(b_ex_dat$gridid_alt) == TRUE)), integer(0)) == TRUE
    identical((which(is.na(b_nex_dat$gridid_alt) == TRUE)), integer(0)) == TRUE
    identical((which(is.na(s_ex_dat$gridid_alt) == TRUE)), integer(0)) == TRUE
    identical((which(is.na(s_nex_dat$gridid_alt) == TRUE)), integer(0)) == TRUE
    
    nrow(b_ex_dat) # copying original data test join
    nrow(b_nex_dat) # copying original data test join
    nrow(s_ex_dat) # copying original data test join
    nrow(s_nex_dat) # copying original data test join
    nrow(b_ex_dat) + nrow(b_nex_dat) + nrow(s_ex_dat) + nrow(s_nex_dat)

    # join all data
    b_dat <- full_join(b_ex_dat, b_nex_dat)
    s_dat <- full_join(s_ex_dat, s_nex_dat)
    
    # test joins
    nrow(b_ex_dat) + nrow(b_nex_dat) == nrow(b_dat)
    nrow(s_ex_dat) + nrow(s_nex_dat) == nrow(s_dat)
    
    # Join all data
    all_dat <- full_join(b_dat, s_dat)
    
    nrow(b_dat) + nrow(s_dat) == nrow(all_dat) # test join
```

### Append data
```{r}
# make rum dat
    rum_dat <- expand_grid(all_dat, cset, .name_repair = "unique")
    
    nrow(cset) * nrow(all_dat) == nrow(rum_dat)
    
    rum_dat %<>% mutate(to_rm = ifelse(str_detect(gridid_alt, "b_") & boat_access %in% "No", 1, 0)) 

# test expand
   table(rum_dat$to_rm) # 0: 23790 1: 5238 
   table(all_dat$boat_access) # No: 97 Yes: 257 
   (97*nrow(cset)) - (97*nrow(s_opts)) # this should == table(rum_dat$to_rm):1
   
# filter data ro remove
   rum_dat %<>% filter(to_rm == 0) 
```
## Land distance

```{r}
# CALCULATE LAND DISTANCE 
rum_dat %<>% 
  mutate(geom_finish = ifelse(str_detect(gridid_alt, "b_"), geom_br, geom_cent)) %>% 
  mutate(geom_finish = st_as_sfc(geom_finish)) %>% 
  mutate(finish_id = ifelse(str_detect(gridid_alt, "b_"), ramp_id, gridid_alt)) %>% 
  mutate(finish_gg = paste0(st_coordinates(geom_finish)[,2], "+", st_coordinates(geom_finish)[,1])) %>% 
  mutate(accom_gg = paste0(st_coordinates(geom_accom)[,2], "+", st_coordinates(geom_accom)[,1])) 

# land_dists <- rum_dat %>% dplyr::select(accom, finish_id, accom_gg, finish_gg) %>% distinct()
# 
# myKey<-readLines("~/Documents/PhD/g.csv")
# register_google(key = myKey)
# 
# Outputs <- gmapsdistance(
#   origin = land_dists$accom_gg,
#   destination = land_dists$finish_gg,
#   mode = "driving",
#   combinations = "pairwise",
#   dep_date = "2024-07-26",
#   dep_time = "06:00:00",
#   key = myKey)
# 
# land_dists$nl_land_km <- Outputs$Distance$Distance/1000
# land_dists$s_trvltime_mins <- (Outputs$Time$Time/60)
# land_dists$s_trvltime_min_rnd <- land_dists$s_trvltime_mins*2

# write.csv(land_dists, paste0("./data/02_data/2.1_nex_land_dists_", sim_name,".csv"))
land_dists <- read.csv(paste0("./data/02_data/2.1_nex_land_dists_", sim_name,".csv"))

rum_dat %<>% left_join(land_dists) 
```

## Travel cost & choice
```{r}
# Choice col
rum_dat %<>%
  mutate(b_choice = ifelse(str_detect(gridid_vis, "b_") & 
                           gridid_vis == gridid_alt & min_nl_km_br == 1, 1, NA)) %>% 
  mutate(s_choice = ifelse(str_detect(gridid_vis, "s_") & 
                           gridid_vis == gridid_alt, 1, NA)) %>% 
  mutate(choice = ifelse(b_choice == 1 | s_choice == 1, 1, NA)) %>% 
  mutate(choice = ifelse(is.na(choice), 0, choice)) %>% 
  mutate(choice_fct = as.factor(choice))
  # choice

    #'[#VALIDATE: TRUE, should equal number of trips]
    sum(rum_dat$choice) == n_distinct(rum_dat$trip_id)

# Travel cost
rum_dat %<>%
        # calc km for shore sites and boat sites
        mutate(total_km = ifelse(str_detect(gridid_alt, "b_"), nl_km_br + nl_land_km, nl_land_km)) %>% 
      
         # fuel cost
        mutate(fc_flt = round(as.numeric((cost/cons_flt)*total_km), 2)) %>% # calc fuel cost
        # mutate(fc2l = round(as.numeric((cost/cons2l)*km_BR), 2)) %>%
        # mutate(fc3l = round(as.numeric((cost/cons3l)*km_BR), 2)) %>%
        # mutate(fc_gam = round(as.numeric((cost/gam_cons)*km_BR), 2)) %>%
  
        # travel time
        # mutate(trvlTime_flt = round(as.numeric(nl_km_br/sp_flt, 2))) %>%
        # mutate(trvlTime2l = round(as.numeric(km_BR/sp2l, 2))) %>%
        # mutate(trvlTime3l = round(as.numeric(km_BR/sp3l), 2)) %>%
        mutate(b_trvltime_gam = round(as.numeric((nl_km_br/gam_sp)/60), 2)*2) %>% # calc travel time for boat
        mutate(total_trvltime = ifelse(str_detect(gridid_alt, "b_"), b_trvltime_gam + s_trvltime_min_rnd,
                                       s_trvltime_min_rnd)) %>% 

        #  trip vott
        # mutate(trp_vott_flt = round(as.numeric(VOTT*trvlTime_flt), 2)*2) %>%
        # mutate(trp_vott2l = round(as.numeric(VOTT*trvlTime2l), 2)*2) %>%
        # mutate(trp_vott3l = round(as.numeric(VOTT*trvlTime3l), 2)*2) %>%
        mutate(trp_vott_gam = round(as.numeric(vott*total_trvltime), 2)) %>% # policy mod

        # total cost
        # mutate(tc_flt = round(as.numeric(fc_flt + trp_vott_flt), 2)) %>%
        # mutate(tc2l = round(as.numeric(fc2l + trp_vott2l), 2)) %>%
        # mutate(tc3l = round(as.numeric(fc3l + trp_vott3l), 2)) %>% 
        # mutate(tc_gam = round(as.numeric(fc_gam + trp_vott_gam), 2)) %>% 
  
        # mutate(fcflt_sp2l = round(as.numeric(fc_flt + trp_vott2l), 2)) %>% 
        # mutate(fcflt_sp3l = round(as.numeric(fc_flt + trp_vott3l), 2)) %>% 
        mutate(fcflt_spgam = round(as.numeric(fc_flt + trp_vott_gam), 2)) ## policy mod
```
## Zone
```{r}
rum_dat$cset <- substr(rum_dat$gridid_alt, 1, 3) # making choice set col to nest
rum_dat$b_s_set <- substr(rum_dat$gridid_alt, 1, 1) # making choice set col to nest: try just boat vs shore
rum_dat$n_e_set <- substr(rum_dat$gridid_alt, 3, 3) # making choice set col to nest: try just ex vs nex

# sz vars to test in model
rum_dat %<>% 
  mutate(b_sz = ifelse(cset %in% c("b_e", "b_n") & sz == 1, 1, 0)) %>%  # boat based sz
  mutate(s_sz = ifelse(cset %in% c("s_e", "s_n") & sim_zone %in% "sz", 1, 0)) %>% # shore bases sz
  mutate(sn_sz = ifelse(cset %in% "s_n" & sim_zone %in% "sz", 1, 0)) %>% # shore based nex sz
  mutate(bn_sz = ifelse(cset %in% "b_n" & sim_zone %in% "sz", 1, 0)) %>% # boat based nex sz
  mutate(sz = ifelse(b_sz == 1 | s_sz == 1, 1, 0)) %>% # this is both current and simn
  mutate(n_sz = ifelse(str_detect(gridid_alt, "nex") & sz == 1, 1, 0)) # nex sz

# sz var to remov from ex fishing choice
rum_dat %<>%
  mutate(zone_rm = ifelse(str_detect(gridid_alt, "b_ex|s_ex") & sz == 1, 1, 0)) # to remove in sim
  
# check - will look really weird - need to rember the choice sets are all combined and the extractiveo ones dont have the current sz in their choice set and if there is no non-extractive activity then i will not be in grid - Current sz which are in the grid are ones that have non extractive sue in them
# tmp <- rum_dat %>% distinct(gridid_alt, .keep_all = TRUE)
# 
# b_tmp <- tmp %>% filter(cset %in% c("b_e", "s_e"))
# 
# ggplot()+
#   geom_sf(data = b_tmp$geom_asc, aes(fill = b_tmp$zone_rm))

ggplot()+
  geom_sf(data = b_ex) +
    geom_sf(data = sc_split, alpha = 0, colour = "red")


# tmp[, c("cset", "gridid_alt", "b_sz", "s_sz", "sn_sz", "bn_sz", "sz", "n_sz", "zone_rm")]
```

# Missing values 
Check for missing values in important cols 
Individual id cols e.g., gridid_b_ex_1 have lots of NA where they have appended which should be 0 

- area/length: fine as some sites don't have area they have length and vice versa
- data_present: is wrong and not needed to will remove
- 

```{r}
rum_dat %<>% 
  mutate(across(contains('gridid_b'), replace_na, 0)) %>% 
  mutate(across(contains('gridid_s'), replace_na, 0))

# check for NAs
summary(rum_dat[, c("choice", "choice_fct", "fcflt_spgam", "ipw", "trip_id", "gridid_alt")]) # make sure no NAs

# ipw
rum_dat[which(is.na(rum_dat$ipw)), ] # just 1 trip id which is allocated to two sites - 

rum_dat %<>% filter(trip_id != 502) 

summary(rum_dat[, c("choice", "choice_fct", "fcflt_spgam", "ipw", "trip_id", "gridid_alt")]) # make sure no NAs
```
# Make fishing RUM
```{r}
fish_dat <- rum_dat %>% 
  filter(trip_id %in% b_ex_dat$trip_id) %>% # filter to just the boat based fishing trips
  filter(cset %in% "b_e")
```


# Save
```{r save}

rum_dat_no_geom <- rum_dat %>% dplyr::select(-c(geom_accom, geometry, geom_asc, geom_cent, geom_br, geom_finish))

fish_dat_no_geom <- fish_dat %>% dplyr::select(-c(geom_accom, geometry, geom_asc, geom_cent, geom_br, geom_finish))

    write_csv(rum_dat, paste0("./data/02_data/2.1_nex_", sim_name,".csv")) # for 3.1?
    write_csv(rum_dat_no_geom, paste0("./data/02_data/2.1_nex_", sim_name,"_stata.csv")) # for stata?
    
    write_csv(fish_dat, paste0("./data/02_data/2.1_nex_ex_", sim_name,".csv")) # for 3.1?
    write_csv(fish_dat_no_geom, paste0("./data/02_data/2.1_nex_ex_", sim_name,"_stata.csv")) # for stata?
```
