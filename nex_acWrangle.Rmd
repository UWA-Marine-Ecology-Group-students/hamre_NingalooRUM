This script creates a grid with associated attributes from a ASC RUM. 

# Set up
```{r setup}
rm(list = ls())

    # knitr options
    knitr::opts_chunk$set(warning = FALSE, message = TRUE, echo = FALSE, fig.align =
                            'center', fig.width = 10, fig.height = 7) 
    
    # libraries 
    library(tidyverse)
    library(dplyr)
    library(ggplot2)
    library(sp)
    library(raster)
    library(rgeos)
    library(rgdal)
    library(sf)
    library(lwgeom)
    library(googledrive)
    library(units)
    library(nngeo)
    library(magrittr)
    library(todor)
    library(mgcv)
    library(sfnetworks)
    library(ggmap)
    # remotes::install_github("jlacko/gmapsdistance")
    library(gmapsdistance)
    
    

    # data
    # BR <- st_read("./data/shp/natBR.shp") # boat ramps
    BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") %>% # from BRtrips.R
      st_transform(crs = 4283 )%>% st_make_valid()
    
    # npz <- st_read("./data/gpkg/wha_ntz_no_shore_fishing.gpkg") %>% 
    #   st_transform(crs = 4283) %>% st_make_valid()
    
    npz <- st_read("./data/gpkg/ntz.gpkg") %>%
      st_transform(crs = 4283) %>% st_make_valid()
    
    grid_base <- st_read("./data/gpkg/ascBase_v4.gpkg") %>% 
      st_transform(crs = 4283) %>% st_make_valid()
    
    sh_asc_base <- st_read("./data/gpkg/sh_asc_base.gpkg") %>% 
      st_transform(crs = 4283)
    
     s_ex_cent <- st_read("./data/gpkg/s_ex_centroids.gpkg") %>% 
      st_transform(crs = 4283)
     
     s_nex_buff <- st_read("./data/gpkg/s_nex_buff.gpkg") %>% 
      st_transform(crs = 4283)
    
     s_nex_cent <- st_read("./data/gpkg/s_nex_cent.gpkg") %>% 
      st_transform(crs = 4283)
     
    accom <- st_read("./data/gpkg/ning_accom.gpkg") %>% 
      st_transform(crs = 4283)
    
    dat <- read_csv("data/01_data/1.2_dat.csv")
    
    # bathy <- raster("./data/raster/NWSbathy.tif") # bathy
    
    # mp <- st_read("./data/gpkg/pmmp_4326.gpkg") %>% 
    #   st_transform(crs = 4283)
    
    coast <- st_read("./data/gpkg/coast.gpkg") %>% 
      st_transform(crs = 4283) %>% 
      dplyr::select(geom) %>% 
      st_make_valid()
    
    
    hol <- read_csv("./data/RAW/Holidays.csv") %>% 
      mutate(Date = as.Date(Date, format = "%d/%m/%y"))

    # consump <- read.csv("./data/RAW/consump.csv")
    
    boat_perf <- read.csv("./data/RAW/boatengines.csv")
    
    vott <- read.csv("./data/RAW/VOTT.csv")
    
    # habitat <- st_read("./data/gpkg/ning_hab.gpkg") %>% 
    #   st_transform(crs = 4283) %>% 
    #   st_make_valid() %>% 
    #   mutate(habitat = tolower(habitat))
    
    # gulf <- st_read("./data/gpkg/exgulf.gpkg") %>% 
    #   st_transform(crs = 4283)
    # 
    #  tant <- st_read("./data/gpkg/launch_areas.gpkg") %>% 
    #   st_transform(crs = 4283)
      # 
      #     CB <- st_read("./data/gpkg/CB_launch.gpkg") %>% 
      # st_transform(crs = 4283)
      # 
    # get fuel csv from here
    # https://www.fuelwatch.wa.gov.au/retail/monthly
    # need to resave as proper csv format
    # jan - apr 2023
    fuel <- read_csv("./data/RAW/Monthly-ULP-prices-Gascoyne-201507-202109.csv")
    
    # models
    cons_mod <- readRDS("./models/cons_mod.rda")
    sp_mod <- readRDS("./models/sp_mod.rda")
    bl_mod <- readRDS("./models/bl_mod.rda")
    
    # simulation
    sim_name <- "sim4"       #'[#NOTE: check simulation name]
    # 
    # sim <- st_read(paste0("./data/gpkg/sims/asc_", sim_name, ".gpkg")) %>% 
    #   st_transform(crs = 4283)
    
    sim <- st_read(paste0("./data/gpkg/sim4_v2.gpkg")) %>% 
      st_transform(crs = 4283) %>% st_make_valid()
    
    # functions
    # source("./functions/spatialFunc.R") # spatial functions
    # source("./functions/ascFunc.R") # function to make asc grid
    
    sf_use_s2(FALSE)
    
    ggplot()+
      geom_sf(data = grid_base) +
      geom_sf(data = sim, fill = "green") +
       geom_sf(data = npz, fill = "blue")
   
    
    #### FUNCTION 
  # depth range function originally from spatial func
depth_range <- function(bathy, polygon){
  poly_crs <- crs(polygon) # store polygons original crs
  bathy_crs <- crs(bathy)  # store raster crs
  poly_to_bathy_crs <- st_transform(polygon, bathy_crs) # re-project polygon to match raster
  r.vals <- raster::extract(bathy, poly_to_bathy_crs) #extract values of raster
  r.min <- unlist(lapply(r.vals, FUN = min)) #take mean for each polygon
  r.max <- unlist(lapply(r.vals, FUN = max)) #take mean for each polygon
  poly_to_bathy_crs$depth_range <- r.max - r.min #merge mean back in to polygon
  polygon <- st_transform(poly_to_bathy_crs, poly_crs)
}

st_centroid_within_poly <- function (poly) {

  # check if centroid is in polygon
  centroid <- poly %>% st_centroid()
  in_poly <- st_within(centroid, poly, sparse = F)[[1]]

  # if it is, return that centroid
  if (in_poly) return(centroid)

  # if not, calculate a point on the surface and return that
  centroid_in_poly <- st_point_on_surface(poly)
  return(centroid_in_poly)
}

dist <- function(centroid_geom, br_geom, RampID, gridid) {
  
  # Calculate non-linear distance 
  
  # extract coordinates
  br <- as.data.frame(st_coordinates(br_geom))
  points <- as.data.frame(st_coordinates(centroid_geom)) 
  
  NGRIDS <- nrow(points) # extract number of grids
  ids <- c(RampID, gridid) # make ids
  
  points <- rbind(br, points) %>% mutate(ID = row_number()) # first obs are the boat ramps
  
  NCELL <- nrow(points) # Set the number of cells in the model
  
  ## Convert the points in the centroids of the polygon to a spatial points file
  points$ID <- as.integer(points$ID)
  points_sf <- st_as_sf(points, coords = c("X", "Y"))
  points_sp <- st_cast(st_geometry(points_sf), "POINT")
  
  ## Figure out which six points are the closest - won't all have six close ones but can start from there
  dist.mat <- st_distance(points_sp) # Great Circle distance since in lat/long
  
  ## Get the IDS for the cells that are neighbours
  n.closest <- 6 # Decide how many neighbours you want to use
  
  neighbours <- as.data.frame(array(0, dim = c(NCELL, n.closest)))
  
  for (i in 1:n.closest) {
    neighbours[,i] <- apply(dist.mat, 1, function(x) { order(x, decreasing = F)[i + 1] })
  }
  
  ## Give the neighbouring points geometry based on the original set of points
  point.list <- list()
  
  for (i in 1:n.closest) {
    
    temp1 <- as.data.frame(neighbours[,i])
    
    temp2 <- temp1 %>%
      rename(ID = "neighbours[, i]") %>% 
      inner_join(., points, by = "ID") %>% 
      st_as_sf(., coords = c("X", "Y")) 
    
    temp3 <- st_cast(st_geometry(temp2), "POINT")
    
    point.list[[i]] <- temp3
    
  }
  
  # CONNECT THE POINTS TO THEIR NEIGHBOURS TO FORM A NETWORK ####
  n <- nrow(points)
  
  ## Form linestrings and then multilinestrings
  multilinestrings <- list()
  
  for (i in 1:n.closest) {
    
    linestring <- point.list[[i]]
    
    temp <- lapply(X = 1:n, FUN = function(x) {
      pair <- st_combine(c(points_sp[x], linestring[x]))
      line <- st_cast(pair, "LINESTRING")
      return(line)
    })
    
    temp2 <- st_multilinestring(do.call("rbind", temp))
    
    multilinestrings[[i]] <- temp2
    
  }
  
  connected <- st_combine(c(multilinestrings[[1]], multilinestrings[[2]], multilinestrings[[3]],   multilinestrings[[4]], multilinestrings[[5]], multilinestrings[[6]]))
  connected <- st_cast(connected, "LINESTRING") # Needs to be a line string rather than multiline for the next step
  
  # setwd(working.dir)
  # st_write(connected, paste0(model.name, sep="_", "network.shapefile.shp"))
  
  # SET UP THE SF NETWORK AND CREATE FULL DISTANCE MATRIX ####
  network <- as_sfnetwork(connected, directed = FALSE) %>%
    activate("edges") %>%
    mutate(weight = edge_length())
  
  ## Calculate the distances from each point to every other point on the network
  net <- activate(network, "nodes")
  network_matrix <- st_network_cost(net, from = points_sf, to = points_sf)
  network_matrix <- network_matrix * 111 # Multiple by 111 to get from degrees to kms
  dim(network_matrix) # Check that the dimensions match up to how many points you think you should have in the network
  
  ## Checks to make sure it's done what you want
  # Checking that short distances between points are the same e.g. 1 -> 2
  # test <- st_distance(points_sf[1,2], points_sf[2,2])
  # test * 111 # 8.2km 
  # network_matrix[1,2] # 8.2km km 
  # 
  # # Checking that points that cross the land are not the same - should be longer in our network matrix
  # # Find two points that are either side of the land and should have a long distances between them
  # plot(points_sf, col = ifelse(points_sf$ID == 1300 | points_sf$ID == 600, "red", "black")) # These are on opposite sides of the cape
  # 
  # test <- st_distance(points_sf[1300,2], points_sf[600,2])
  # test*111 # 115km
  # 
  # test_matrix <- st_network_cost(net, from = points_sf[1300, 2], to = points_sf[600,2])
  # test_matrix*111 # 131km
  
  colnames(network_matrix) <- ids # change names to ids
  
  nbr <- nrow(br) + 1 # set gather limit
  
  # remove boat ramps, append gridIDs and gather data frame
  network_matrix %<>% 
    as.data.frame() %>% 
    dplyr::select(1:4) %>% 
    slice(nbr:nrow(.)) %>% 
    mutate(gridid = gridid) %>% 
    gather("RampID", "nl_km_br", 1:length(.) - 1) %>% 
    mutate(nl_km_br = round(nl_km_br, 2))
  
  # nrow(dist) == nrow(grid)
  
  # Calculate linear distance
  l_dist <- as.data.frame(set_units(st_distance(centroid_geom, br_geom), km))
  l_dist %<>% gather("RampID", "l_km_br", 1:length(.)) %>% 
    mutate(l_km_br = round(as.numeric(l_km_br), 2))
  
  # append linear distance
  network_matrix$l_km_br <- l_dist$l_km_br
  
  return(network_matrix)
}

# snap points to line
st_snap_points = function(x, y, max_dist = 1000) {

  if (inherits(x, "sf")) n = nrow(x)
  if (inherits(x, "sfc")) n = length(x)

  out = do.call(c,
                lapply(seq(n), function(i) {
                  nrst = st_nearest_points(st_geometry(x)[i], y)
                  nrst_len = st_length(nrst)
                  nrst_mn = which.min(nrst_len)
                  if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
                  return(st_cast(nrst[nrst_mn], "POINT")[2])
                })
  )
  return(out)
}
```

# Joining external data
## Fuel
```{r}
fuel %<>%
  mutate(TripMonth = gsub("[^a-zA-Z]", "", Month)) %>%
  mutate(season = ifelse(TripMonth %in% c("Sep", "Oct"), "Spring", 
                           ifelse(TripMonth %in% c("Jul", "Aug"), "Winter",
                                  "Autumn"))) %>% 
  mutate(numYear = as.numeric(paste0("20", as.numeric(gsub("[^0-9]", "", Month))))) %>%
  mutate(cost = Average/100)

dat %<>% left_join(fuel[, c("TripMonth", "numYear", "cost")])
```

## Boat length
Predicting as a function of party size to fill NAs
```{r}
# dat %<>% rename(PartySize = Party)
# tmp <- dat %>% filter(is.na(BoatLength) & SiteType == "Boat") %>% dplyr::select(TripID, BoatLength, PartySize)
# # unique(tmp$Party)
# 
# # Filling Party size where it exists
# tmp %<>% mutate(PartySize = ifelse(PartySize %in% c("6f", "Two couples 2 kids", "3F, 2M, 1b"), 6, 
#                                     ifelse(PartySize %in% c("2f", "2 dudes", "2males", "Couple", "1M 1b"), 2, 
#                                            ifelse(PartySize %in% c("2f, 2kids", "4 friends", "2 couples", "4 mates", "1m1b", "Couple, 2g", "Couple,2g 1b"), 4,
#                                                   ifelse(PartySize %in% c("Man", "1M"), 1, 
#                                                          ifelse(PartySize %in% c("2b1g", "3M", "3m"), 3, NA))))))
# 
#       tmp$lm_bl <- predict(bl_mod, tmp) # predicting boatlength using party size
#       tmp$lm_bl <- round(as.numeric(tmp$lm_bl), 2)
#       dat %<>%  left_join(tmp[, c("TripID", "lm_bl")])
#       
#       dat %<>% 
#         mutate(BoatLength = ifelse(SiteType == "Boat" & !is.na(lm_bl), lm_bl, BoatLength)) %>% # appending modelled boat length
#         mutate(BoatLength = ifelse(SiteType == "Boat" & is.na(BoatLength), mean(BoatLength, na.rm = T), BoatLength)) # filling rest of boat length with NAs
```

## VOTT
```{r}
# VOTT 
    dat %<>% left_join(vott[, c("Postcode", "ann_inc_21", "VOTT_21")]) 

    tmp <- dat %>% filter(!is.na(ann_inc_21) & !is.na(BoatLength)) %>% mutate(ann_inc_21 = as.numeric(ann_inc_21))

    lm_ann_inc <- lm(ann_inc_21 ~ BoatLength, data = tmp)
    

      # ggplot(dat = tmp, aes(x = ann_inc_21, y = BoatLength)) +
      #   geom_point() +
      #   stat_smooth(method = "lm")
      
      dat$lm_ann_inc <- predict(lm_ann_inc, dat)
      
      # mean(vott$ann_inc_21, na.rm = T) - mean(vott$ann_inc_16, na.rm = T)
      
      dat %<>%
        mutate(ann_inc = ifelse(!is.na(ann_inc_21), ann_inc_21, lm_ann_inc)) %>% 
        mutate(ann_inc = ifelse(is.na(ann_inc), mean(ann_inc, na.rm = T), ann_inc)) %>% 
        mutate(VOTT = round((ann_inc/(38*52))/3, 2))
```

## Boat specs
```{r}
# Consumption
boat_perf %<>%  
  filter(kmperh < 4000) %>% 
    mutate(boat_size2L = ifelse(boatlength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(boatlength <= 3.75, "S", 
                            ifelse(boatlength <= 6.75, "M", "L"))) %>% 
  mutate(cons = kmperl/nEngines)

boat3L <- boat_perf %>% 
  group_by(boat_size3L) %>% 
  summarise(sp3l = median(kmperh),
            cons3l = median(cons))

boat2L <- boat_perf %>% 
  group_by(boat_size2L) %>% 
  summarise(sp2l = median(kmperh),
            cons2l = median(cons))
  
dat %<>% 
  mutate(BoatLength = ifelse(is.na(BoatLength), mean(BoatLength, na.rm = TRUE), BoatLength)) %>%
  mutate(boat_size2L = ifelse(BoatLength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(BoatLength <= 3.75, "S", 
                            ifelse(BoatLength <= 6.75, "M", "L")))  %>% 
  left_join(boat2L[, c("boat_size2L", "cons2l", "sp2l")], by = "boat_size2L") %>% 
  left_join(boat3L[, c("boat_size3L", "cons3l", "sp3l")], by = "boat_size3L")

dat %<>% 
  mutate(cons_flt = median(boat_perf$cons)) %>% 
  mutate(sp_flt = median(boat_perf$kmperh))

# modeled consumption
 temp <- dat %>% 
        dplyr::select(BoatLength) %>% 
        rename(boatlength = BoatLength) %>% 
        st_drop_geometry()
      
      gam_cons <- predict(cons_mod, temp)
      gam_sp <- predict(sp_mod, temp)
      
      dat$gam_cons <- as.numeric(gam_cons)
      dat$gam_sp <- as.numeric(gam_sp)


rm(fuel, boat2L, boat3L, vott, temp, gam_cons, sp_cons, cons_mod, sp_mod, tmp, bl_mod, lm_ann_inc, boat_perf, gam_sp)
```

# Filtering
All data filters have to be done before making the choice set.
```{r}
dat %<>% 
  filter(facYear > 2020) %>% 
  mutate(Activity = ifelse(Activity %in% c("Diving", "Snorkeling", "Shark cleaning", "Megafauna"), "Wildlife", Activity)) %>% 
  mutate(Activity = ifelse(Activity %in% c("Explore", "JetSki"), "Other", Activity)) %>% 
  mutate(FishingType = ifelse(ActivityType %in% "Both", NA, FishingType)) %>% 
  mutate(ActivityType = ifelse(ActivityType %in% "Both", "Non-Extractive", ActivityType)) %>% 
  mutate(FishingType = ifelse(FishingType %in% "Casting" & SiteType %in% "Boat" | FishingType %in% "Squidding", "Nearshore", FishingType)) %>% 
  mutate(FishingType = ifelse(FishingType %in% "Demersal" & SiteType %in% "Shore", "Casting", FishingType)) %>% 
  mutate(FishingType = ifelse(is.na(FishingType) & SiteType %in% "Shore" & ActivityType %in% "Extractive", "Casting", FishingType)) %>% 
  filter(!(Activity %in% "Other"))  %>% 
  filter(!(Activity %in% "Fishing") & ActivityType %in% "Non-Extractive" | ActivityType %in% "Extractive") %>% 
  mutate(Activity = ifelse(Activity %in% "Fishing", FishingType, Activity))

    dat %<>% 
        filter(!is.na(UseLat), !is.na(UseLong)) %>% # filtering empty coords
      st_as_sf(coords = c("UseLong", "UseLat"), crs = 4283)  %>% ## make sf object
      mutate(dem_only = ifelse(Dem_bin == 1 & Pel_bin == 0 & nrSh_bin == 0 & Mol_bin == 0 &
                                 Crust_bin == 0, 1, 0)) 

      # filter(ActivityType == "Extractive") %>% # filtering activity
      # filter(FishingType %in% c("Demersal", "Casting")) %>% # fishing RUM
      # filter(SiteType %in% "Boat") %>% # filtering activity
      # filter(str_detect(Site, "BR"))
      
    # need one trip per row (longest site visited on trip)
    dat %<>% 
      group_by(PersonID, TripID) %>% 
      slice(which.max(decDuration)) %>% 
      ungroup() 
    
      dat <- st_crop(dat, grid_base) # removing outliers 
    
      #'[#VALIDATE: TRUE, no duplicated trip IDs)]
      identical((which(duplicated(dat$TripID) == TRUE)), integer(0)) == TRUE
      
    dat %<>% 
      mutate(UseLong = st_coordinates(geometry)[,1]) %>%
      mutate(UseLat = st_coordinates(geometry)[,2]) 
    
      write.csv(dat, "data/02_data/2.1_filtered_dat.csv")
      
      rm(hol)
```

## Accomodation 

```{r}
# aggregate accomodation
dat %<>% 
  mutate(Accom = ifelse(Resident %in% "Yes" & Postcode == 6707, "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Resident %in% "Yes" & Postcode == 6701, "CoralBay", Accom)) %>% 
  mutate(Accom = ifelse(is.na(Accom) & UseLat < -22.5, "CoralBay", Accom)) %>% 
  mutate(Accom = ifelse(is.na(Accom) & UseLat > -22.5, "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Accom %in% c("ExmouthEscape", "RACHolPark", "MantaResort", "Potshot", "ExmouthVillas", "NingalooBreeze", "NingalooLodge", "OspreyHolVillage"), "Exmouth", Accom)) %>% 
  mutate(Accom = ifelse(Accom %in% c("BayView", "PeoplesPark"), "CoralBay", Accom))

# rename accom geometry
accom %<>%
  rename(geom_accom = geom) %>% as.data.frame() 

dat %<>% left_join(accom) # appen accom geom to dat

rm(accom)
```


# Weighting
Following protocol outed in KAP

## Step 5.1: Identify starta to be weighted
  - boat ramp (no others necessary because on intensive field trip)
  
The primary sampling unit (psuid) is a shift am/pm at a specific boat ramp on a specific date where at least one survey was conducted
```{r}
## Prepping data 
tot_smpl <- nrow(dat) # total samples

# Append frequency of each starta to data set
br_freq <- table(dat$Site) %>% as.data.frame() %>% rename(br_freq = Freq)

dat %<>% left_join(br_freq, by = c("Site" = "Var1"))
```

## Step 5.2: Calculate inclusion probability
```{r}
# Step 5.2a: calulate inclusion probability
dat %<>%
  mutate(br_inprob = br_freq/tot_smpl)
```

## Step 5.3: Calculate IPW
```{r}
dat %<>% mutate(ipw = 1/br_inprob)

rm(br_freq, tot_smpl)
```

# Grids
## b_ex
### Make grid
```{r}
g1 <- "b_ex"

b_ex_dat <- dat %>% filter(ActivityType %in% "Extractive" & SiteType %in% "Boat" & str_detect(Site, "BR"))
# # 
# b_ex <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = b_ex_dat, from = 0.03, 
#                 by = 0.02, crs = 4283, vert = FALSE)
# 
# 
# b_ex %<>% st_transform(crs = 4283) %>% st_cast("MULTIPOLYGON")
# 
# st_write(b_ex, paste0("./data/gpkg/sims/2.1_asc_manual_edit_", g1, "_", sim_name, "_4283.gpkg"), append = FALSE) # need to write with st_write to open in QGISRUMs

   b_ex <- st_read(paste0("./data/gpkg/", g1, "_grid_", sim_name, "_qgis.gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
   
ggplot()+
  geom_sf(data = b_ex_dat, aes(colour = Site))
```

### Atrributes
```{r}
# RAMPS
b_ex_dat %<>%
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR"), "Bundegi", NA)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("ExmouthBR"), "Exmouth", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("TantabiddiBR"), "Tantabiddi", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("CoralBayBR"), "Coral Bay", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(is.na(Site), "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR", "ExmouthBR") & UseLong < 114, "Tantabiddi", Ramp_name))
  
ggplot()+
  geom_sf(data = b_ex_dat, aes(colour = Ramp_name))

# IDs
## remove wrong id col made by function
    b_ex %<>% dplyr::select(-contains("gridID_"))

## Make new gridid_alt col
    b_ex %<>% mutate(gridid_alt = paste(g1, row_number(), sep = "_"))

## make binary gridid_col
    for (i in unique(b_ex$gridid_alt)) {
    gridid = ifelse(b_ex$gridid_alt == i, 1, 0)
    b_ex[,length(b_ex) + 1] <- gridid
    colnames(b_ex)[ncol(b_ex)] <- paste0("gridid_", i)
  }

# AREA
# needs redone after manual manipulation
    b_ex$area <- as.numeric(round(set_units(st_area(b_ex), km^2), 2))
    
    # USE COUNT
# needs redone after manual manipulation   
    b_ex$use_count <- lengths(st_intersects(b_ex, b_ex_dat))
    
  ggplot() +
    geom_sf(data = b_ex, aes(fill = as.factor(use_count)))

# CENTROID   
    centroid <- st_centroid_within_poly(b_ex) # gets centroid of every grid cell
    b_ex$centroid <- centroid$geom # append centroid to grid 
 # checking centroids are correct
  ggplot() +
    geom_sf(data = b_ex) +
      geom_sf(data = b_ex$centroid, size = 0.5, colour = "red") + theme_classic()
    
  b_ex %<>% filter(!(gridid_alt %in% "b_ex_48"))  # double
  
## NON-LINEAR DISTANCE FROM BR TO CENTROID
  # create distance matrix from every ramp to every grid
  b_ex_dist <- dist(b_ex$centroid, BRtrips$geometry, BRtrips$RampID, b_ex$gridid_alt) # create distance dataframe
  
  b_ex_dist %<>% rename(gridid_alt = gridid) # making id cols match

  b_ex %<>% left_join(b_ex_dist, by = "gridid_alt") # appending to grid
  
  nrow(b_ex) == n_distinct(b_ex$gridid_alt)*nrow(BRtrips) # check dataset is the correct size
  

  ## GRID GEOMETRIES
  
  b_ex %<>% 
    rename(geom_asc = geom,
                   geom_cent = centroid)
    
  # 
  BRtrips %<>% ## Appending BRtrips
    rename(geom_br = geometry) %>%
    as.data.frame() %>%
    mutate(RampID = as.character(RampID))
  
  b_ex %<>% left_join(BRtrips, by = "RampID") # appending to grid
  
# check all geometries work
  ggplot() +
    geom_sf(data = b_ex$geom_asc) +
    geom_sf(data = b_ex$geom_cent, colour = "red") +
     geom_sf(data = b_ex$geom_br, colour= "blue")
  
## checking distances
    ggplot(b_ex) +
      geom_sf(aes(geometry = geom_asc, fill = nl_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Non-linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    ggplot(b_ex) +
      geom_sf(aes(geometry = geom_asc, fill = l_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    # REMOVE INVALID CELLS
##'[#NOTE:Check empty grids before removing]
    
  # Remove current sz and cells with no data presnet
    b_ex %<>% filter(sz_current == 0 & use_count != 0)

  # plot should have no zeros and check data to make sure
    ggplot() +
      geom_sf(data = b_ex, aes(fill = as.factor(use_count)))
    
            # isolating grid ID to append to dat
    b_ex_grid <- b_ex %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    b_ex_dat %<>% 
      st_join(b_ex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
    b_ex_dat %<>% filter(!is.na(gridid_vis)) 
    
    ggplot() +
      geom_sf(data = b_ex, aes(fill = as.factor(use_count))) +
      geom_sf(data = b_ex_dat, size = 0.5)
```

## b_nex
### Make grid
```{r}
g2 <- "b_nex"

b_nex_dat <- dat %>% filter(ActivityType %in% "Non-Extractive" & SiteType %in% "Boat"& str_detect(Site, "BR"))

# b_nex <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = b_nex_dat, from = 0.03, by = 0.02, crs = 4283, vert = FALSE)
# 
# b_nex %<>% st_transform(crs = 4283) %>% st_cast("MULTIPOLYGON")
# 
# st_write(b_nex, paste0("./data/gpkg/sims/2.1_asc_manual_edit_", g2, "_", sim_name, "_4283.gpkg"), append = FALSE) # need to write with st_write to open in QGISRUMs

   b_nex <- st_read(paste0("./data/gpkg/", g2, "_grid_", sim_name, "_qgis.gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```

### Attributes
```{r}

# RAMPS
b_nex_dat %<>%
  mutate(Ramp_name = ifelse(Site %in% c("BundegiBR"), "Bundegi", NA)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("ExmouthBR"), "Exmouth", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("TantabiddiBR"), "Tantabiddi", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(Site %in% c("CoralBayBR"), "Coral Bay", Ramp_name)) %>%
  mutate(Ramp_name = ifelse(is.na(Site), "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% "ExmouthBR" & UseLong < 114, "Tantabiddi", Ramp_name)) %>% 
  mutate(Ramp_name = ifelse(Site %in% "TantabiddiBR" & UseLat < -22.11, "Exmouth", Ramp_name))

ggplot()+
  geom_sf(data = b_nex_dat, aes(colour = Ramp_name))

# IDs
## remove wrong id col made by function
    b_nex %<>% dplyr::select(-contains("gridID_"))

## Make new gridid_alt col
    b_nex %<>% mutate(gridid_alt = paste(g1, row_number(), sep = "_"))

## make binary gridid_col
    for (i in unique(b_nex$gridid_alt)) {
    gridid = ifelse(b_nex$gridid_alt == i, 1, 0)
    b_nex[,length(b_nex) + 1] <- gridid
    colnames(b_nex)[ncol(b_nex)] <- paste0("gridid_", i)
  }

# AREA
# needs redone after manual manipulation
    b_nex$area <- as.numeric(round(set_units(st_area(b_nex), km^2), 2))
    
# USE COUNT
# needs redone after manual manipulation   
    b_nex$use_count <- lengths(st_intersects(b_nex, b_nex_dat))

# CENTROID   
    centroid <- st_centroid_within_poly(b_nex) # gets centroid of every grid cell
    b_nex$centroid <- centroid$geom # append centroid to grid 
 # checking centroids are correct
  ggplot() +
    geom_sf(data = b_nex) +
      geom_sf(data = b_nex$centroid, size = 0.5, colour = "red") + theme_classic()
  
## NON-LINEAR DISTANCE FROM BR TO CENTROID
  # create distance matrix
  b_nex_dist <- dist(b_nex$centroid, BRtrips$geom_br, BRtrips$RampID, b_nex$gridid_alt) # create distance dataframe
  
  b_nex_dist %<>% rename(gridid_alt = gridid) # making id cols match

  b_nex %<>% left_join(b_nex_dist, by = "gridid_alt") # appending to grid
  
  nrow(b_nex) == n_distinct(b_nex$gridid_alt)*nrow(BRtrips) # check dataset is the correct size
  

  ## GRID GEOMETRIES
  
  b_nex %<>% 
    rename(geom_asc = geom,
                   geom_cent = centroid) %>%
    mutate(RampID = as.character(RampID))
  
  b_nex %<>% left_join(BRtrips, by = "RampID") # appending to grid
  
# check all geometries work
  ggplot() +
    geom_sf(data = b_nex$geom_asc) +
    geom_sf(data = b_nex$geom_cent, colour = "red") +
    geom_sf(data = b_nex$geom_br, colour= "blue")
  
## checking distances
    ggplot(b_nex) +
      geom_sf(aes(geometry = geom_asc, fill = nl_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Non-linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    ggplot(b_nex) +
      geom_sf(aes(geometry = geom_asc, fill = l_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = geom_br, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    # REMOVE INVALID CELLS
##'[#NOTE:Check empty grids before removing]  
     
  # Remove current sz and cells with no data presnet
    b_nex %<>% filter(use_count != 0)
    
      # plot should have no zeros and check data to make sure
    ggplot() +
      geom_sf(data = b_nex, aes(fill = as.factor(use_count)))+
      geom_sf(data = b_nex_dat)
    
            # isolating grid ID to append to dat
    b_nex_grid <- b_nex %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    b_nex_dat %<>% 
      st_join(b_nex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
    
    ggplot() +
      geom_sf(data = b_nex, aes(fill = as.factor(use_count))) +
      geom_sf(data = b_nex_dat, size = 0.5)
```


## s_ex
### Make grids
```{r}
g3 <- "s_ex"

s_ex_dat <- dat %>% filter(ActivityType %in% "Extractive" & SiteType %in% "Shore")
# there is one island based activity that needs removed
# 
# # # check none are actually offshore/island based 
# ggplot() +
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat, colour = "red")
# 
# # filtering out shore activity more than 1 km form shore
s_ex_dat %<>%
  mutate(dist_coast = as.numeric(st_distance(s_ex_dat, sh_asc_base))) %>%
  filter(dist_coast < 1000)
# 
# # check none are actually offshore/island based 
# ggplot()+ 
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat, aes(colour = dist_coast))
#   
# 
# snap_geom <- st_snap_points(s_ex_dat, sh_asc_base)
# 
# snap_geom <- as.data.frame(snap_geom)
# 
# s_ex_dat %<>% 
#       mutate(snap_geom = snap_geom$geometry) 
# 
# ggplot()+ 
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_ex_dat$snap_geom, colour = "red")
# 
# 
# s_ex_dat %<>%
#   mutate(snap_lon = st_coordinates(snap_geom)[,1]) %>%
#   mutate(snap_lat = st_coordinates(snap_geom)[,2]) 
# 
# write.csv(s_ex_dat, paste0("./data/02_data/2.1_sh_asc_manual_edit_", g3, "_", sim_name, ".csv"), append = FALSE) # need to write with st_write to open in QGISRUMs

# I manually split up the sh_asc_base by sims and sz and remove al tnhat didnt have any point. I took note of the zone and sim_zone for shore fishing

   s_ex_line <- st_read(paste0("./data/gpkg/", g3, "_grid_", sim_name, ".gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```
### Attributes

s_ex_dat : data
s_ex_line: line
s_ex_buff: polyon buffer
s_ex_cent: centroid of buffer

```{r}
# there are two data points which need to be removed becas ethey are fishing in sz 

    s_ex_line %<>% mutate(gridid_alt = paste(g3, row_number(), sep = "_"))

# calculating length
    s_ex_line$length <- as.numeric(round(set_units(st_length(s_ex_line), km), 2))
    
    s_ex_buff <- st_buffer(s_ex_line, 0.007) 
    # s_ex_buff %>% rename(geom_buff = geom) # units in degree 

    for (i in unique(s_ex_buff$gridid_alt)) {
    gridid = ifelse(s_ex_buff$gridid_alt == i, 1, 0)
    s_ex_buff[,length(s_ex_buff) + 1] <- gridid
    colnames(s_ex_buff)[ncol(s_ex_buff)] <- paste0("gridid_", i)
  }

    # make sure that the point in sz which need to be removed are not in buffer
    ggplot() +
      geom_sf(data = s_ex_buff) +
      geom_sf(data = s_ex_dat, size = 0.5)
    
    s_ex_dat %<>% mutate(to_rm = ifelse(st_intersects(s_ex_dat, s_ex_buff), 1, 0)) %>% 
      filter(!is.na(to_rm))
  
  # pDouble check there are no lines, without data and vice versa 
    ggplot() +
      geom_sf(data = s_ex_buff,  aes(colour = zone)) +
        # geom_sf(data = s_ex_dat, size = 0.5)
        geom_sf(data = s_ex_cent, size = 0.5)
    
    # Append centroids to s_ex_buf
     s_ex_cent %<>% 
      rename(geom_cent = geom) %>% # make geom name individual 
       mutate(cent_id = row_number()) # adding id to append to 
       
     s_ex_buff %<>% st_join(s_ex_cent, join = st_intersects) # do st_join
     
    s_ex_cent %<>% as.data.frame() 
  
    s_ex_buff %<>% left_join(s_ex_cent) 
    
     s_ex_buff %<>% 
      rename(geom_asc = geom) # make geoms names individual
     
     ggplot() +
       geom_sf(data = s_ex_buff$geom_asc) + 
       geom_sf(data = s_ex_buff$geom_cent) +
       geom_sf(data = s_ex_dat, colour = "red")
    
    # isolating grid ID to append to dat
     
  s_ex_grid <- s_ex_buff %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    s_ex_dat %<>% 
      st_join(s_ex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
```

## s_nex
### Make grid
```{r}
g4 <- "s_nex"

s_nex_dat <- dat %>% filter(ActivityType %in% "Non-Extractive" & SiteType %in% "Shore")
# there is one island based activity that needs removed
# 
# # # check none are actually offshore/island based 
# ggplot() +
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat, colour = "red")
# 
# # # filtering out shore activity more than 1 km form shore
s_nex_dat %<>%
  mutate(dist_coast = as.numeric(st_distance(s_nex_dat, sh_asc_base))) %>%
  filter(dist_coast < 1000)
# # 
# # # check none are actually offshore/island based 
# ggplot()+
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat, aes(colour = dist_coast))
# #   
snap_geom <- st_snap_points(s_nex_dat, sh_asc_base)
# # 
snap_geom <- as.data.frame(snap_geom)
# # 
s_nex_dat %<>%
      mutate(snap_geom = snap_geom$geometry)
# # 
# ggplot()+
#   geom_sf(data = sh_asc_base) +
#   geom_sf(data = s_nex_dat$snap_geom, colour = "red")
# # 
# # 
s_nex_dat %<>%
  mutate(snap_lon = st_coordinates(snap_geom)[,1]) %>%
  mutate(snap_lat = st_coordinates(snap_geom)[,2])

# write.csv(s_nex_dat, paste0("./data/02_data/2.1_sh_asc_manual_edit_", g4, "_", sim_name, ".csv"), append = FALSE) # need to write with st_write to open in QGISRUMs

# I manually split up the sh_asc_base by sims and sz and remove al tnhat didnt have any point. I took note of the zone and sim_zone for shore fishing

   s_nex_line <- st_read(paste0("./data/gpkg/", g4, "_grid_", sim_name, ".gpkg")) %>%
      st_transform(crs = 4283) %>% st_make_valid()
```

### Attributes
```{r}
# there are two data points which need to be removed becas ethey are fishing in sz 
    s_nex_buff %<>% mutate(gridid_alt = paste(g4, row_number(), sep = "_"))

# calculating length
    # s_nex_line$length <- as.numeric(round(set_units(st_length(s_nex_line), km), 2))

    for (i in unique(s_nex_buff$gridid_alt)) {
    gridid = ifelse(s_nex_buff$gridid_alt == i, 1, 0)
    s_nex_buff[,length(s_nex_buff) + 1] <- gridid
    colnames(s_nex_buff)[ncol(s_nex_buff)] <- paste0("gridid_", i)
  }

    # make sure that the point in sz which need to be removed are not in buffer
    ggplot() +
      geom_sf(data = s_nex_buff) +
      geom_sf(data = s_nex_dat, size = 0.5)
    
    s_nex_dat %<>% mutate(to_rm = ifelse(st_intersects(s_nex_dat, s_nex_buff), 1, 0)) %>% 
      filter(!is.na(to_rm))
  
  # pDouble check there are no lines, without data and vice versa 
    ggplot() +
      geom_sf(data = s_nex_buff,  aes(colour = zone)) +
        # geom_sf(data = s_nex_dat, size = 0.5)
        geom_sf(data = s_nex_cent, size = 0.5)
    
    # Append centroids to s_nex_buf
     s_nex_cent %<>% 
      rename(geom_cent = geom) %>% # make geom name individual 
       mutate(cent_id = row_number()) # adding id to append to 
       
     s_nex_buff %<>% st_join(s_nex_cent, join = st_intersects) # do st_join
     
    s_nex_cent %<>% as.data.frame() 
  
    s_nex_buff %<>% left_join(s_nex_cent) 
    
     s_nex_buff %<>% 
      rename(geom_asc = geom) # make geoms names individual
     
     ggplot() +
       geom_sf(data = s_nex_buff$geom_asc) + 
       geom_sf(data = s_nex_buff$geom_cent)
       geom_sf(data = s_nex_dat, colour = "red")
       
       # calculate length
       c <- s_nex_buff %>% st_cast("MULTILINESTRING")
      c <- st_intersection(c, coast)
      c$length <- as.numeric(round(set_units(st_length(c), km), 2))
       
       ggplot()+
         geom_sf(data = c, aes(colour = as.factor(length)))
       
       c %<>% dplyr::select(length)
       
       s_nex_buff %<>% st_join(c, join = st_intersects) #
    
    # isolating grid ID to append to dat
     
  s_nex_grid <- s_nex_buff %>%
      dplyr::select(gridid_alt, geom_asc) %>%
      distinct()

    # allocating sites to grids
    s_nex_dat %<>% 
      st_join(s_nex_grid, left = T, join = st_intersects) %>% 
      rename(gridid_vis = gridid_alt)
```


## Full choice set



## this needs to be dne after i have made full choice set 

```{r}
# CALCULATE LAND DISTANCE 
# distance from accomodation to boat ramp
rm(BRtrips, coast, dat, grid_base, npz, sh_asc_base, sim, temp, g1, gridid, i, sim_name, depth_range, st_centroid_within_poly)

temp <- expand.grid(b_ex_dat$geom_accom, b_ex$geom_br) %>% rename(accom = Var1, ramp = Var2)
tempid <- expand.grid(b_ex_dat$TripID, b_ex$gridid_alt) %>% rename(TripID = Var1, gridid_alt = Var2)
temp <- cbind(temp, tempid) 

# make and start and finish data
  # right_join(b_ex_dat, by = c("Var1" = "geom_accom")) %>%
  # left_join(b_ex, by = c("Var2" = "geom_br"))
# 
# 
length(b_ex$geom_br)*length(b_ex_dat$geom_accom)

myKey<-readLines("~/Documents/PhD/g.csv")
register_google(key = myKey)

Outputs <- gmapsdistance(
  origin = temp$accom,
  destination = temp$ramp,
  mode = "driving",
  combinations = "pairwise",
  dep_date = "2024-07-26",
  dep_time = "06:00:00",
  key = myKey)

temp$DistanceLand_km<-Outputs$Distance$Distance/1000
temp$TravelTimeLand_mins<-Outputs$Time$Time/60
```

