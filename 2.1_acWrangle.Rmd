This script creates a grid with associated attributes from a ASC RUM. 

# Set up
```{r setup}
    rm(list = ls())

    # knitr options
    knitr::opts_chunk$set(warning = FALSE, message = TRUE, echo = FALSE, fig.align =
                            'center', fig.width = 10, fig.height = 7) 
    
    # libraries 
    library(tidyverse)
    library(dplyr)
    library(ggplot2)
    library(sp)
    library(raster)
    library(rgeos)
    library(rgdal)
    library(sf)
    library(lwgeom)
    library(googledrive)
    library(units)
    library(nngeo)
    library(magrittr)
    library(todor)
    library(mgcv)

    # data
    # BR <- st_read("./data/shp/natBR.shp") # boat ramps
    BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") %>% # from BRtrips.R
      st_transform(crs = 4283)
    
    npz <- st_read("./data/gpkg/ntz.gpkg") %>% 
      st_transform(crs = 4283)
    
    grid_base <- st_read("./data/gpkg/ascBase_v2.gpkg") %>% 
      st_transform(crs = 4283)
    
    dat <- read_csv("data/01_data/1.2_dat.csv")
    
    bathy <- raster("./data/raster/NWSbathy.tif") # bathy
    
    # mp <- st_read("./data/gpkg/pmmp_4326.gpkg") %>% 
    #   st_transform(crs = 4283)
    
    coast <- st_read("./data/gpkg/coast.gpkg") %>% 
      st_transform(crs = 4283) %>% 
      dplyr::select(geom) 
    
    hol <- read_csv("./data/RAW/Holidays.csv") %>% 
      mutate(Date = as.Date(Date, format = "%d/%m/%y"))

    # consump <- read.csv("./data/RAW/consump.csv")
    
    boat_perf <- read.csv("./data/RAW/boatengines.csv")
    
    vott <- read.csv("./data/RAW/VOTT.csv")
    
    habitat <- st_read("./data/gpkg/ning_hab.gpkg") %>% 
      st_transform(crs = 4283) %>% 
      st_make_valid() %>% 
      mutate(habitat = tolower(habitat))
    
    gulf <- st_read("./data/gpkg/exgulf.gpkg") %>% 
      st_transform(crs = 4283)
    
    # get fuel csv from here
    # https://www.fuelwatch.wa.gov.au/retail/monthly
    # need to resave as proper csv format
    # jan - apr 2023
    fuel <- read_csv("./data/RAW/Monthly-ULP-prices-Gascoyne-201507-202109.csv")
    
    # models
    cons_mod <- readRDS("./models/cons_mod.rda")
    sp_mod <- readRDS("./models/sp_mod.rda")
    bl_mod <- readRDS("./models/bl_mod.rda")
    
    # simulation
    sim_name <- "sim1"       #'[#NOTE: check simulation name]  
    
    sim <- st_read(paste0("./data/gpkg/sims/asc_", sim_name, ".gpkg")) %>% 
      st_transform(crs = 4283)
    
    # functions
    source("./functions/spatialFunc.R") # spatial functions
    source("./functions/ascFunc.R") # function to make asc grid
    source("./functions/theme.R") # plot theme
    source("./functions/genFunc.R") # function for smple weighting
    
    sf_use_s2(FALSE)
```

# Joining external data
## Fuel
```{r}
fuel %<>%
  mutate(TripMonth = gsub("[^a-zA-Z]", "", Month)) %>%
  mutate(season = ifelse(TripMonth %in% c("Sep", "Oct"), "Spring", 
                           ifelse(TripMonth %in% c("Jul", "Aug"), "Winter",
                                  "Autumn"))) %>% 
  mutate(numYear = as.numeric(paste0("20", as.numeric(gsub("[^0-9]", "", Month))))) %>%
  mutate(cost = Average/100)

dat %<>% left_join(fuel[, c("TripMonth", "numYear", "cost")])
```

## Boat length
Predicting as a function of party size to fill NAs
```{r}
# dat %<>% rename(PartySize = Party)
# tmp <- dat %>% filter(is.na(BoatLength) & SiteType == "Boat") %>% dplyr::select(TripID, BoatLength, PartySize)
# # unique(tmp$Party)
# 
# # Filling Party size where it exists
# tmp %<>% mutate(PartySize = ifelse(PartySize %in% c("6f", "Two couples 2 kids", "3F, 2M, 1b"), 6, 
#                                     ifelse(PartySize %in% c("2f", "2 dudes", "2males", "Couple", "1M 1b"), 2, 
#                                            ifelse(PartySize %in% c("2f, 2kids", "4 friends", "2 couples", "4 mates", "1m1b", "Couple, 2g", "Couple,2g 1b"), 4,
#                                                   ifelse(PartySize %in% c("Man", "1M"), 1, 
#                                                          ifelse(PartySize %in% c("2b1g", "3M", "3m"), 3, NA))))))
# 
#       tmp$lm_bl <- predict(bl_mod, tmp) # predicting boatlength using party size
#       tmp$lm_bl <- round(as.numeric(tmp$lm_bl), 2)
#       dat %<>%  left_join(tmp[, c("TripID", "lm_bl")])
#       
#       dat %<>% 
#         mutate(BoatLength = ifelse(SiteType == "Boat" & !is.na(lm_bl), lm_bl, BoatLength)) %>% # appending modelled boat length
#         mutate(BoatLength = ifelse(SiteType == "Boat" & is.na(BoatLength), mean(BoatLength, na.rm = T), BoatLength)) # filling rest of boat length with NAs
```

## VOTT
```{r}
# VOTT 
    dat %<>% left_join(vott[, c("Postcode", "ann_inc_21", "VOTT_21")]) 

    tmp <- dat %>% filter(!is.na(ann_inc_21) & !is.na(BoatLength)) %>% mutate(ann_inc_21 = as.numeric(ann_inc_21))

    lm_ann_inc <- lm(ann_inc_21 ~ BoatLength, data = tmp)
    

      # ggplot(dat = tmp, aes(x = ann_inc_21, y = BoatLength)) +
      #   geom_point() +
      #   stat_smooth(method = "lm")
      
      dat$lm_ann_inc <- predict(lm_ann_inc, dat)
      
      # mean(vott$ann_inc_21, na.rm = T) - mean(vott$ann_inc_16, na.rm = T)
      
      dat %<>%
        mutate(ann_inc = ifelse(!is.na(ann_inc_21), ann_inc_21, lm_ann_inc)) %>% 
        mutate(ann_inc = ifelse(is.na(ann_inc), mean(ann_inc, na.rm = T), ann_inc)) %>% 
        mutate(VOTT = round((ann_inc/(38*52))/3, 2))
```

## Boat specs
```{r}
# Consumption
boat_perf %<>%  
  filter(kmperh < 4000) %>% 
    mutate(boat_size2L = ifelse(boatlength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(boatlength <= 3.75, "S", 
                            ifelse(boatlength <= 6.75, "M", "L"))) %>% 
  mutate(cons = kmperl/nEngines)

boat3L <- boat_perf %>% 
  group_by(boat_size3L) %>% 
  summarise(sp3l = median(kmperh),
            cons3l = median(cons))

boat2L <- boat_perf %>% 
  group_by(boat_size2L) %>% 
  summarise(sp2l = median(kmperh),
            cons2l = median(cons))
  
dat %<>% 
  mutate(BoatLength = ifelse(is.na(BoatLength), mean(BoatLength, na.rm = TRUE), BoatLength)) %>%
  mutate(boat_size2L = ifelse(BoatLength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(BoatLength <= 3.75, "S", 
                            ifelse(BoatLength <= 6.75, "M", "L")))  %>% 
  left_join(boat2L[, c("boat_size2L", "cons2l", "sp2l")], by = "boat_size2L") %>% 
  left_join(boat3L[, c("boat_size3L", "cons3l", "sp3l")], by = "boat_size3L")

dat %<>% 
  mutate(cons_flt = median(boat_perf$cons)) %>% 
  mutate(sp_flt = median(boat_perf$kmperh))

# modeled consumption
 temp <- dat %>% 
        dplyr::select(BoatLength) %>% 
        rename(boatlength = BoatLength) %>% 
        st_drop_geometry()
      
      gam_cons <- predict(cons_mod, temp)
      gam_sp <- predict(sp_mod, temp)
      
      dat$gam_cons <- as.numeric(gam_cons)
      dat$gam_sp <- as.numeric(gam_sp)


rm(fuel, boat2L, boat3L, vott, temp, gam_cons, sp_cons, cons_mod, sp_mod, tmp, bl_mod)
```

# Filtering
All data filters have to be done before making the choice set.
```{r}
    dat %<>% 
      filter(ActivityType == "Extractive") %>% # filtering activity
      filter(str_detect(Site, "BR")) %>% 
      filter(!is.na(UseLat), !is.na(UseLong)) %>% # filtering empty coords
      st_as_sf(coords = c("UseLong", "UseLat"), crs = 4283)  ## make sf object
      
    # need one trip per row (longest site visited on trip)
    dat %<>% 
      group_by(PersonID, TripID) %>% 
      slice(which.max(decDuration)) %>% 
      ungroup() 
    
      dat <- st_crop(dat, grid_base) # removing outliers 
    
      #'[#VALIDATE: TRUE, no duplicated trip IDs)]
      identical((which(duplicated(dat$TripID) == TRUE)), integer(0)) == TRUE
```

# Weighting
```{r}
    # prep for getting survey weights
    # will duplicate rows which are in public and school holiday - changing to school for weighting and removing duplicates
    dat %<>% left_join(hol, by = c("SurveyDate" = "Date"))

    tmp <- dat[which(duplicated(dat$TripID)), ] %>% dplyr::select(TripID)

    dat %<>%  mutate(Holiday = ifelse(dat$TripID %in% tmp$TripID, "school", Holiday)) %>% distinct()
    
    dat <- dat %>%
      mutate(DayType = weekdays(Date_posix, abbreviate = TRUE)) %>% 
      mutate(DayType = ifelse(DayType %in% c("Sat", "Sun"), "Weekend", "Weekday")) %>%
      mutate(DayType = ifelse(Holiday %in% "public", "Weekend", DayType)) %>%
      mutate(Holiday = as.factor(ifelse(Holiday %in% "school", "1", "0"))) %>%
      unite("psuid", c(SurveyDate, Time, Site), remove = F, sep = " ")

    # calculating nipw weights
    ## site
    w_site <- even_nipw(df = dat, psuid = psuid, w_col = "Site") 
    dat %<>% left_join(w_site[, c("Site", "Site_nipw")])
    
    # time
    w_time <- even_nipw(df = dat, psuid = psuid, w_col = "Time") 
    dat %<>% left_join(w_time[, c("Time", "Time_nipw")])
      
    ## holiday - not balanced
    # Holidays
    nhol <- hol %>% filter(Holiday == "school")  %>% nrow() # dates of school holidays in sample year
    
    w_hol <- as.data.frame(table(dat$Holiday)) %>% 
      mutate(target = ifelse(Var1 %in% 0, ((365*4) - nhol)/(365*4), nhol/(365*4))) %>% 
      mutate(real = Freq/(sum(Freq))) %>% 
      mutate(ipw = target/real) %>% 
      mutate(hol_nipw = ipw/(sum(ipw))) %>% 
      rename(Holiday = Var1)
    
    sum(w_hol$hol_nipw)  # checkpoint: == 1 
    dat %<>% left_join(w_hol[, c("Holiday", "hol_nipw")]) # append

    # DayType
    wdat <- dat %>% distinct(psuid, .keep_all = TRUE) # filtering to primary sampling units
    
    w_daytype <- as.data.frame(table(wdat$DayType)) %>%
      mutate(target = ifelse(Var1 %in% "Weekend", (4*(2*52))/360, (4*(5*52))/360)) %>%
      mutate(real = Freq/sum(Freq)) %>% 
      mutate(ipw = target/real) %>% 
      mutate(dt_nipw = ipw/sum(ipw)) %>% 
      rename(DayType = Var1)
    
    sum(w_daytype$dt_nipw) # checkpoint: == 1
    dat %<>% left_join(w_daytype[, c("DayType", "dt_nipw")])  # append

    # overall weight
    dat %<>% mutate(ipw = Site_nipw + hol_nipw + dt_nipw + Time_nipw) # w_time removed so same as south cpoast
    
    # dat %<>% mutate(nipw = ipw/sum(ipw))
    # 
    # sum(dat$nipw)
```

# ASC grid

Creates smallest ASC grid possible within the base grid, given the distribution of data. Each cell must have at least 1 data point in it. 
Calculates basic stats for simulation and current marine park (eg. area, beach access etc.)
```{r message = FALSE}
# asc grid
    grid <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = dat, from = 0.03,
                    by = 0.02, crs = 4283, vert = FALSE) 

#'[#NOTE:Check empty grids before removing]  
  emp <- grid[which(grid$data_present == FALSE),]
  grid %<>% filter(gridID_alt != emp$gridID_alt) 
  
  ggplot() +
  geom_sf(data = grid, aes(fill = area))
```

# Grid attributes

## Habitat
Calculates the area (km2) of each habitat type in each individual grid cell (site)
```{r habitat}
# grid <- habitat_area(sf_habitat = habitat, col_habitat = 1, sf_grid = grid, id_grid = gridID) # need to update updated pivot wioder from spread
habitat %<>% st_make_valid() %>% filter(habitat != "pelagic")
hab <- st_intersection(habitat, grid) # This gives you all the individual areas where there is overlap between the habitat and grid, includes original ID
hab <- st_make_valid(hab) # make intersection valid
hab$hab_area <- round(set_units(st_area(hab), km^2), 2) # calculate the area of each habitats in intersection grids
hab %<>% mutate(hab_area = as.numeric(hab_area))
hab <- hab %>% pivot_wider(names_from = "habitat", values_from = "hab_area", values_fill = 0)

habs <- unique(habitat$habitat)

hab_grid <- hab %>%
  group_by(gridID_alt) %>%
  summarise_at(habs, .funs = sum, .keep_all = T) %>%
  ungroup() %>%
  st_drop_geometry()

hab_grid[2:4] <- hab_grid[2:4] - 1 # dont know why function above is summing and adding 1

#'[#VALIDATE: there should be one row for every individual grid ID]

grid %<>% left_join(hab_grid, by = "gridID_alt")

# checks
which(grid$lagoon > grid$area)
which(grid$rreef > grid$area)
which(grid$reef > grid$area)

summary(grid$lagoon)
summary(grid$rreef)
summary(grid$reef)

ggplot()+
  geom_sf(data = grid, aes(fill = lagoon), lwd = 0.05)
ggplot()+
  geom_sf(data = grid, aes(fill = rreef), lwd = 0.05)
ggplot()+
  geom_sf(data = grid, aes(fill = reefs), lwd = 0.05)

grid %<>% mutate(reefs = rreef + reef) # sum reefs into one

#ADD IN chnage NA to 0
```

## Dist from BR
```{r}
# st_geometry(grid) <- "geom"

 grid <-  ascAtt(ascGrid = grid, grid_id = "gridID_alt", point = dat, br = BRtrips, br_id = "RampID",
              crs = 4283)
 
     # distance of centroid of cells to mainland
    km_mainland <- dist_mainland(grid$centroid, coast)
    km_mainland$gridID_alt <- grid$gridID_alt
    km_mainland %<>% distinct()
    
    grid <- left_join(grid, km_mainland) %>% 
      rename(offshore_dist = km_mainland)
```

## Land
```{r land present}

coast %<>%  st_cast("POLYGON")
coast$area <- as.numeric(set_units(st_area(coast), km^2)) # area of polygons in coast sf

# Distance from mainland
# Adjacent to land
## extracting islands from coast polygon
islands <- coast %>%                                    
  arrange(desc(area)) %>% 
  slice(2:nrow(coast))

ggplot() +
  geom_sf(data = islands)
  
## create binary column indicating whether grid cell is adjacent to island
grid %<>% 
  mutate(isl_adj = ifelse(as.list(st_intersects(grid, islands)) %in% "integer(0)", 0, 1))

ggplot() +
  geom_sf(data = grid$asc_geom, aes(fill = as.factor(grid$isl_adj)))
```

## Depth
```{r}
    grid <- mean_depth(bathy, grid) # get average depth of grid
    grid %<>% mutate(depth = abs(depth))

    ggplot() +
      geom_sf(data = grid, aes(fill = depth), lwd = 0.05) + 
      scale_fill_continuous(trans = 'reverse') +
      theme_classic()
```

## Rugousity
```{r}
rug <- terra::terrain(bathy, v = c("roughness"))

rugousity <- raster::extract(rug, grid, na.rm = TRUE, fun = max)

grid$rug <- as.numeric(rugousity)

# check
plot(rug) 

ggplot() +
  geom_sf(data = grid, aes(fill = rug), lwd = 0.05) + theme_classic()
```
## Gulf
```{r}
grid %<>% 
  mutate(gulf = ifelse(as.list(st_intersects(grid, gulf)) %in% "integer(0)", 0, 1))

ggplot() +
  geom_sf(data = grid, aes(fill = as.factor(gulf)), lwd = 0.05) + theme_classic()
```

## Append data
```{r}
    # isolating grid ID to append to dat
    gridID_vis <- grid %>%
      dplyr::select(gridID_alt, asc_geom) %>%
      distinct()

    # allocating sites to grids
    dat  %<>% 
      st_join(gridID_vis, left = T, join = st_intersects) 
    
     # check there are no missing gridID_vis
    a <- dat[which(is.na(dat$gridID_alt)), ]
    a
    ggplot() +
      geom_sf(data = grid) +
      geom_sf(data = a)
    
    # fill missing gridID_vis with nearest adjacent if applicable
    tmp <- dat %>% filter(is.na(dat$gridID_alt)) %>% dplyr::select(TripID)
    
    tmp %<>% st_join(gridID_vis, join = st_nearest_feature)
    # check filling in the missing gridID vis has worked
    g <- grid %>% filter(gridID_alt == tmp$gridID_alt)
     
    ggplot() +
      geom_sf(data = grid) +
      geom_sf(data = g, fill = 'red')+
      geom_sf(data = a)
    
    # append missing gridIDs
    tmp %<>% st_drop_geometry()
    
   dat %<>% 
     left_join(tmp, by = c("TripID")) %>% 
     mutate(gridID_alt.x = ifelse(is.na(gridID_alt.x), gridID_alt.y, gridID_alt.x)) %>% 
     rename(gridID_alt = gridID_alt.x) %>% 
     dplyr::select(-gridID_alt.y)
    
    # selecting attributes, and tidying
    dat %<>%
      rename(gridID_vis = gridID_alt, dat_geom = geometry) %>%
      #'[#NOTE: select vars for model] 
      #'Mandatory vars: TripID, PersonID, gridID_vis, Site, BoatLength  
      dplyr::select(TripID, PersonID, gridID_vis, Site, TripDate, MedianTime, BoatLength, cost, ipw, Postcode, 
                    cons_flt, sp_flt, cons2l, sp2l, cons3l, sp3l, gam_cons, gam_sp, VOTT, ann_inc, 
                    KeptUndam, CaughtUndam,Dem, Dem_bin, Start_hr, BaitLure, Age, exTimes12m, TripMonth, numYear, 
                    decDuration, FishingType) %>%
      distinct() %>%
      mutate(RampID = ifelse(Site %in% "ExmouthBR", 85, NA),
             RampID = ifelse(Site %in% "CoralBayBR", 72, RampID),
             RampID = ifelse(Site %in% "BundegiBR", 73, RampID),
             RampID = ifelse(Site %in% "TantabiddiBR", 87, RampID)) %>%
      # mutate(UseLong = st_coordinates(.)[,1]) %>%
      # mutate(UseLat = st_coordinates(.)[,2]) %>%
      # dplyr::select(-Site) %>%
      as.data.frame()
    
    # ifelse(is.na(dat$gridID_vis)) {st_join(dat, gridID_vis, join = st_nearest_feature)}
    
    #'[#VALIDATE: TRUE, there are no unassigned gridIDs]
    
    identical((which(is.na(dat$gridID_alt) == TRUE)), integer(0)) == TRUE
    
    # join
    t1 <- nrow(dat) # copying original data test join

    dat <- inner_join(dat, grid, by = "RampID") 
    
    #'[#VALIDATE: TRUE, number of sites * number of trips == nrow(dat), unless sites have been removed eg. beach launching sites]
    
    t1*nrow(gridID_vis) == nrow(dat)
```

# Fisher attributes
## Distance BR to use

Distance from the boat ramp to the centroid of data points in each grid that launched from that boat ramp - if not takes centroid of grid cell. 
```{r message=FALSE}
#'[#NOTE:could wrap below bit in separate function - use_centroid and other could be site_centroid] 

    dat <- dat %>% 
      st_as_sf() # turn to sf object
    
    # get centroid of use points
    tmp <- dat %>%
      group_by(gridID_vis, RampID) %>%
      summarise(use_centroid = st_union(dat_geom)) %>%
      st_centroid() %>%
      ungroup() %>%
      mutate(id = row_number())
    
    # validation plot: is the use centroid in the middle of each set of uses per boat ramp
    # ggplot() +
    #   geom_sf(data = dat, aes(geometry = asc_geom)) +
    #   geom_sf(data = dat, aes(geometry = dat_geom, color = as.factor(RampID)), size = 0.25) +
    #   geom_sf(data = tmp, aes(geometry = use_centroid, color = as.factor(RampID)), shape = 8) +
    #   ggtitle("Check dots are in centroid of uses in cells for each boat ramp") +
    #   theme(plot.title = element_text(hjust = 0.5)) +
    #   theme_classic() +
    #   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    #         legend.spacing.y = unit(0.75, "cm"))
    
    # making distance data frame
    dist <- as.data.frame(round(set_units(st_distance(tmp, BRtrips), km), 2)) # distance from use centroid to each BR
    names(dist) <- unique(BRtrips$RampID) 
    dist$gridID_vis <- tmp$gridID_vis 
    dist$RampID <- tmp$RampID 
    dist$id <- tmp$id 
    len <- length(dist) - 3
    dist %<>% gather("BRdist", "use.centroid_km.br", 1:len) 
    dist[] <- sapply(dist, as.numeric) # change all cols to numeric
    
    
    dist <- dist %>% 
      filter(RampID == BRdist) %>% 
      dplyr::select(-c(id, BRdist)) %>% 
      rename(gridID_alt = gridID_vis) # got to join to alt not visited
    
    dat <- as.data.frame(dat)
    
    dat <- left_join(dat, dist, by = c("RampID", "gridID_alt")) # join
    
    dat <- dat %>% 
      mutate(km_BR = ifelse(is.na(use.centroid_km.br), site.centroid_km.br,
                            use.centroid_km.br)) # distance tc to be measured from
    
    # validation plot
    # ggplot(dat) +
    #   geom_sf(aes(geometry = asc_geom, fill = use.centroid_km.br), lwd = 0.25) +
    #   geom_sf(aes(geometry = br_geom), size = 3) +
    #   theme_classic() +
    #   scale_fill_distiller(palette = "Blues") +
    #   labs(fill = "km from BR", colour = "") +
    #   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    #         legend.spacing.y = unit(0.75, "cm")) +
    #   facet_grid(.~fac_br_id) +
    #   ggtitle("Check distances look accurate")
```

## Swell
```{r}
dat %<>%
    mutate(centLong = st_coordinates(centroid)[,1]) %>%
    mutate(centLat = st_coordinates(centroid)[,2])

  #extracting swell
   hsws <- get_hs_ws_day(dat$TripDate, dat$centLong, dat$centLat) # getting hs and ws

   # making a numeric hour column
  dat$MedianHour <- as.numeric(gsub("\\:.*$", "", dat$MedianTime))

  # catagorising time of day
  dat$TimeOfDay <- with(dat,  ifelse(MedianHour >= 5 & MedianHour <= 10, "Morning",
                            ifelse(MedianHour >= 11 & MedianHour <= 13, "Midday",
                                   ifelse(MedianHour >= 14 & MedianHour <= 18, "Afternoon", NA))))

  # appending swell and wind speed
  hsws_df <- as.data.frame(hsws)

  dat <- dat %>%
    mutate(swell = ifelse(TimeOfDay %in% "Morning", hsws$hs_morning,
                                ifelse(TimeOfDay %in% "Midday", hsws$hs_midday, hsws$hs_afternoon))) %>%
    mutate(wind = ifelse(TimeOfDay %in% "Morning", hsws$wspeed_morning,
                                ifelse(TimeOfDay %in% "Midday", hsws$wspeed_midday,
                                       hsws$wspeed_afternoon)))
```
 
## Cost and choice
```{r choice and travel cost}

       dat <- dat %>%
        mutate(choice = ifelse(gridID_vis == gridID_alt, 1, 0)) %>% 
      #   # mutate(land_fc = round(as.numeric((cost/(100/12))*accom_br), 2)*2) %>% 
      #   # mutate(water_fc = round(as.numeric((cost/consump)*km_BR), 2)*2) %>% #changing fuel&cost
      #   # mutate(lm_fc = round(as.numeric((cost/lm_cons)*km_BR), 2)*2) %>% 
      #  
         # fuel cost
        mutate(fc_flt = round(as.numeric((cost/cons_flt)*km_BR), 2)) %>% # policy mod
        mutate(fc2l = round(as.numeric((cost/cons2l)*km_BR), 2)) %>%
        mutate(fc3l = round(as.numeric((cost/cons3l)*km_BR), 2)) %>%
        mutate(fc_gam = round(as.numeric((cost/gam_cons)*km_BR), 2)) %>%
  
      #   
        # travel time
        mutate(trvlTime_flt = round(as.numeric(km_BR/sp_flt, 2))) %>%
        mutate(trvlTime2l = round(as.numeric(km_BR/sp2l, 2))) %>%
        mutate(trvlTime3l = round(as.numeric(km_BR/sp3l), 2)) %>%
        mutate(trvlTime_gam = round(as.numeric(km_BR/gam_sp), 2)) %>% # policy mod

        #  trip vott
        mutate(trp_vott_flt = round(as.numeric(VOTT*trvlTime_flt), 2)*2) %>%
        mutate(trp_vott2l = round(as.numeric(VOTT*trvlTime2l), 2)*2) %>%
        mutate(trp_vott3l = round(as.numeric(VOTT*trvlTime3l), 2)*2) %>%
        mutate(trp_vott_gam = round(as.numeric(VOTT*trvlTime_gam), 2)*2) %>% # policy mod

        # total cost
        mutate(tc_flt = round(as.numeric(fc_flt + trp_vott_flt), 2)) %>%
        mutate(tc2l = round(as.numeric(fc2l + trp_vott2l), 2)) %>%
        mutate(tc3l = round(as.numeric(fc3l + trp_vott3l), 2)) %>% 
        mutate(tc_gam = round(as.numeric(fc_gam + trp_vott_gam), 2)) %>% 
  
        mutate(fcflt_sp2l = round(as.numeric(fc_flt + trp_vott2l), 2)) %>% 
        mutate(fcflt_sp3l = round(as.numeric(fc_flt + trp_vott3l), 2)) %>% 
        mutate(fcflt_spgam = round(as.numeric(fc_flt + trp_vott_gam), 2)) ## policy mod

    #'[#VALIDATE: TRUE, should equal number of trips]
    sum(dat$choice) == n_distinct(dat$TripID)
```
## Transformations
```{r}
    dat$arealog <- log(dat$area + 1)
    dat$offdist_log <- log(dat$offshore_dist + 1)
    # dat$offdist_log_kids <- dat$offdist_log * dat$kids
    dat$fcflt_aninc <- dat$fc_flt * dat$ann_inc
    dat$bl_offdist <- dat$BoatLength * dat$offdist_log
```

## Filtering SZ
  - Current sz will have no data and therefore no value so are removed
  - Simulated sz that have no data have no value so are  removed
```{r}
    # Remove sites with no recreational value
    dat <- dat %>%  filter(sz_value == 1 | is.na(sz_value))
    
    # remove observations that have visited the current sz (removed above)
    sz_current_w_use <- setdiff(unique(dat$gridID_vis), unique(dat$gridID_alt))
    
    dat2 <- dat %<>% filter(!(gridID_vis %in% sz_current_w_use))
    
    #'[#VALIDATE: TRUE, no difference between gridID_alt/vis as every cells needs data]
  
     setdiff(unique(dat$gridID_vis), unique(dat$gridID_alt))
     setdiff(unique(dat$gridID_alt), unique(dat$gridID_vis))
     
    
     
    # removing sz columns
    sz_to_remove <- dat %>% 
      dplyr::select(num_range("sz", 1:100)) %>% 
      summarise_all(sum) 
    
    sz_to_remove <- names(sz_to_remove[, which(sz_to_remove %in% 0)])
     
    dat_rum_sf <- dat %>% dplyr::select(-c(sz_to_remove))
    dat_rum_df <- dat %>% dplyr::select(-c(sz_to_remove, asc_geom, br_geom, centroid, dat_geom))
    dat_df <- dat %>% dplyr::select(-c(asc_geom, br_geom, centroid, dat_geom))
    
    #'[#TODO: check this]  
    nrow(dat) == n_distinct(dat_df$gridID_alt) * n_distinct(dat_df$TripID)
```

# Save
```{r save}
    # full grid including sites with no recreational value
    saveRDS(dat, paste0("./data/gpkg/sims/2.1_ascCS_",sim_name ,"_4283.gpkg"))
    write_csv(dat_df, paste0("./data/02_data/2.1_asc_", sim_name,".csv"))
    
    # full grid excluding sites with no recreational value
    saveRDS(dat_rum_sf, paste0("./data/gpkg/sims/2.1_ascCS_rum_", sim_name,"_4283.gpkg")) # script 3.1
    write_csv(dat_rum_df, paste0("./data/02_data/2.1_asc_rum_", sim_name,".csv")) # stata
    
    # simplified ascGrid for QGIS (geom, ID)
    st_write(gridID_vis,
             paste0("./data/gpkg/sims/2.1_ascCSQ", sim_name, "_4283.gpkg"),
             append = FALSE) # need to write with st_write to open in QGISRUMs
```
