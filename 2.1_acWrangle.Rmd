# Wrangle data for ASC RUM

## Set up
```{r setup}
    # knitr options
    knitr::opts_chunk$set(warning = FALSE, message = TRUE, echo = FALSE, fig.align =
                            'center', fig.width = 10, fig.height = 7) 
    
    # libraries 
    library(tidyverse)
    library(dplyr)
    library(ggplot2)
    library(sp)
    library(raster)
    library(rgeos)
    library(rgdal)
    library(sf)
    library(lwgeom)
    library(googledrive)
    library(units)
    library(nngeo)
    library(magrittr)
    library(todor)
    
    # data
    # BR <- st_read("./data/shp/natBR.shp") # boat ramps
    BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") %>% # from BRtrips.R
      st_transform(crs = 4283)
    
    npz <- st_read("./data/gpkg/ntz.gpkg") %>% 
      st_transform(crs = 4283)
    
    grid_base <- st_read("./data/gpkg/ascBase_v2.gpkg") %>% 
      st_transform(crs = 4283)
    
    dat <- read_csv("data/01_data/1.2_dat.csv")
    
    # mp <- st_read("./data/gpkg/pmmp_4326.gpkg") %>% 
    #   st_transform(crs = 4283)
    
    coast <- st_read("./data/gpkg/coast.gpkg") %>% 
      st_transform(crs = 4283) %>% 
      dplyr::select(geom) 
    
    hol <- read_csv("./data/RAW/Holidays.csv") %>%
      mutate(Date = as.POSIXct(Date, format = "%d/%m/%y"))

    # consump <- read.csv("./data/RAW/consump.csv")
    
    boat_perf <- read.csv("./data/RAW/boatengines.csv")
    
    vott <- read.csv("./data/RAW/VOTT.csv")
    
    # get fuel csv from here
    # https://www.fuelwatch.wa.gov.au/retail/monthly
    # need to resave as proper csv format
    # jan - apr 2023
    fuel <- read_csv("./data/RAW/Monthly-ULP-prices-Gascoyne-201507-202109.csv")
    
    # models
    cons_mod <- readRDS("./models/cons_mod.rda")
    sp_mod <- readRDS("./models/sp_mod.rda")
    
    # simulation
    sim_name <- "sim1"       #'[#NOTE: check simulation name]  
    
    sim <- st_read(paste0("./data/gpkg/sims/asc_", sim_name, ".gpkg")) %>% 
      st_transform(crs = 4283)
    
    # functions
    source("./functions/spatialFunc.R") # spatial functions
    source("./functions/ascFunc.R") # function to make asc grid
    source("./functions/theme.R") # plot theme
    source("./functions/genFunc.R") # function for smple weighting
    
    sf_use_s2(FALSE)
```

## Data prep

```{r}

fuel %<>%
  mutate(TripMonth = gsub("[^a-zA-Z]", "", Month)) %>%
  mutate(numYear = as.numeric(paste0("20", as.numeric(gsub("[^0-9]", "", Month))))) %>%
  mutate(cost = Average/100)

dat %<>% left_join(fuel[, c("TripMonth", "numYear", "cost")])


# VOTT 
 dat %<>% 
   left_join(vott[, c("Postcode", "ann_inc", "VOTT")]) %>% 
   mutate(ann_inc = mean(ann_inc, na.rm = TRUE), ann_inc) %>% 
   mutate(VOTT = mean(VOTT, na.rm = TRUE), VOTT)
   
 
 # Consumption
boat_perf %<>%  
  filter(kmperh < 4000) %>% 
    mutate(boat_size2L = ifelse(boatlength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(boatlength <= 3.75, "S", 
                            ifelse(boatlength <= 6.75, "M", "L"))) %>% 
  mutate(cons = kmperl/nEngines)

boat3L <- boat_perf %>% 
  group_by(boat_size3L) %>% 
  summarise(sp3l = median(kmperh),
            cons3l = median(cons))

boat2L <- boat_perf %>% 
  group_by(boat_size2L) %>% 
  summarise(sp2l = median(kmperh),
            cons2l = median(cons))
  
dat %<>% 
   mutate(BoatLength = ifelse(is.na(BoatLength), mean(BoatLength, na.rm = TRUE), BoatLength)) %>%
  mutate(boat_size2L = ifelse(BoatLength <= 3.75, "S", "L")) %>%
  mutate(boat_size3L = ifelse(BoatLength <= 3.75, "S", 
                            ifelse(BoatLength <= 6.75, "M", "L"))) %>% 
  left_join(boat2L[, c("boat_size2L", "cons2l", "sp2l")], by = "boat_size2L") %>% 
  left_join(boat3L[, c("boat_size3L", "cons3l", "sp3l")], by = "boat_size3L")

dat %<>% 
  mutate(cons_flt = median(boat_perf$cons)) %>% 
  mutate(sp_flt = median(boat_perf$kmperh))
  

# modeled consumption
 temp <- dat %>% 
        dplyr::select(BoatLength) %>% 
        rename(boatlength = BoatLength) %>% 
        st_drop_geometry()
      
      gam_cons <- predict(cons_mod, temp)
      gam_sp <- predict(sp_mod, temp)
      
      dat$gam_cons <- as.numeric(gam_cons)
      dat$gam_sp <- as.numeric(gam_sp)


rm(fuel, boat2L, boat3L, vott, temp, gam_cons, sp_cons, cons_mod, sp_mod)
```

All data filters have to be done before making the choice set.

```{r}
    dat %<>% 
      filter(ActivityType == "Extractive") %>% # filtering activity
      filter(str_detect(Site, "BR")) %>% 
      filter(!is.na(UseLat), !is.na(UseLong)) %>% # filtering empty coords
      st_as_sf(coords = c("UseLong", "UseLat"), crs = 4283)  ## make sf object
      
    # need one trip per row (longest site visited on trip)
    dat %<>% 
      group_by(PersonID, TripID) %>% 
      slice(which.max(decDuration)) %>% 
      ungroup() 
    
      dat <- st_crop(dat, grid_base) # removing outliers 
    
      #'[#VALIDATE: TRUE, no duplicated trip IDs)]
      identical((which(duplicated(dat$TripID) == TRUE)), integer(0)) == TRUE
      
      dat %<>%
        filter(!is.na(BoatLength))
      
      ggplot()+
        geom_sf(data = dat)
```


```{r}
    # for getting survey weights
    dat <- dat %>%
      mutate(SurveyDate_posix = as.POSIXct(SurveyDate, format = "%m/%d/%Y %H:%M:%S") +
               8*60*60) %>%
      mutate(Time = format(SurveyDate_posix, "%p")) %>%
      mutate(DayType = weekdays(SurveyDate_posix, abbreviate = TRUE)) %>%
      mutate(DayType = ifelse(DayType %in% c("Sat", "Sun"), "Weekend", "Weekday")) %>%
      mutate(SurveyDate_posix = as.POSIXct(SurveyDate, format = "%m/%d/%Y")) %>%
      mutate(Hol = ifelse(SurveyDate_posix %in% hol$Date, hol$Holiday, NA)) %>%
      mutate(DayType = ifelse(Hol %in% "public", "Weekend", DayType)) %>%
      mutate(Hol = ifelse(Hol %in% "school", 1, 0)) %>%
      unite("psuid", c(SurveyDate_posix, Time), remove = F, sep = " ")

    
    # # calculating even weights
    # dat <- even_weights(df = dat, psuid = psuid, w_col = "Time")
    dat <- even_weights(df = dat, psuid = psuid, w_col = "Site")

    # calculate uneven weights
    # Holidays
    dny <- (n_distinct(dat$facYear)*365)
    nhol <- hol %>% filter(Holiday == "school")  %>% nrow()
    w_hol1 = nhol/dny
    w_hol0 = (dny - nhol)/dny

    ## checkpoint: == 1
    w_hol1 + w_hol0

    # append
    dat %<>% mutate(w_hol = ifelse(Hol %in% 1, w_hol1, w_hol0))

    # DayType
    wdat <- dat %>% distinct(psuid, .keep_all = TRUE)
    daytype_smpl <- as.data.frame(table(wdat$DayType)) %>%
      mutate(w = ifelse(Var1 %in% "Weekend", Freq/(2*52), Freq/(5*52))) %>%
      mutate(w_daytype = w/sum(w)) %>% # scaling
      rename(DayType = Var1)

    ## checkpoint: == 1
    sum(daytype_smpl$w_daytype)

    # append
    dat %<>% left_join(daytype_smpl[, c("DayType", "w_daytype")])

    # overall weight
    dat %<>% mutate(smpl_w = w_Site*w_hol*w_daytype)
```

## ASC grid and simulation stats

Creates smallest ASC grid possible within the base grid, given the distribution of data. Each cell must have at least 1 data point in it. 
Calculates basic stats for simulation and current marine park (eg. area, beach access etc.)

```{r message = FALSE}
# asc grid
    grid <- ASCgrid(poly = grid_base, sz_current = npz, sz_sim = sim, point = dat, from = 0.03,
                    by = 0.02, crs = 4283, vert = FALSE) 

#'[#NOTE:Check empty grids before removing]  
  emp <- grid[which(grid$data_present == FALSE),]
  grid %<>% filter(gridID_alt != emp$gridID_alt) 
```

## Attributes


```{r}
st_geometry(grid) <- "geom"

 grid <-  ascAtt(ascGrid = grid, grid_id = "gridID_alt", point = dat, br = BRtrips, br_id = "RampID",
              crs = 4283)
 
     # distance of centroid of cells to mainland
    km_mainland <- dist_mainland(grid$centroid, coast)
    km_mainland$gridID_alt <- grid$gridID_alt
    km_mainland %<>% distinct()
    
    grid <- left_join(grid, km_mainland) %>% 
      rename(offshore_dist = km_mainland)
```
## Data wrangle
```{r}
    # isolating grid ID to append to dat
    gridID_vis <- grid %>%
      dplyr::select(gridID_alt, asc_geom) %>%
      distinct()

    # allocating sites to grids
    dat  %<>% st_join(gridID_vis, left = T, join = st_intersects)

    # selecting attributes, and tidying
    dat %<>%
      rename(gridID_vis = gridID_alt, dat_geom = geometry) %>%
      #'[#NOTE: select vars for model] 
      #'Mandatory vars: TripID, PersonID, gridID_vis, Site, BoatLength  
      dplyr::select(TripID, PersonID, gridID_vis, Site, BoatLength, cost, smpl_w, Postcode) %>% 
      distinct() %>%
      mutate(RampID = ifelse(Site %in% "ExmouthBR", 85, NA),
             RampID = ifelse(Site %in% "CoralBayBR", 72, RampID),
             RampID = ifelse(Site %in% "BundegiBR", 73, RampID),
             RampID = ifelse(Site %in% "TantabiddiBR", 87, RampID)) %>%
      # mutate(UseLong = st_coordinates(.)[,1]) %>%
      # mutate(UseLat = st_coordinates(.)[,2]) %>%
      # dplyr::select(-Site) %>%
      as.data.frame()

    # check there are no missing gridID_vis
    # a <- dat[which(is.na(dat$gridID_vis)), ]
    # a
    # 
    # ggplot() +
    #   geom_sf(data = grid$asc_geom) +
    #   geom_sf(data = a$dat_geom)
    
    #'[#VALIDATE: TRUE, there are no unassigned gridIDs]
    
    identical((which(is.na(dat$gridID_alt) == TRUE)), integer(0)) == TRUE
    
    # join
    t1 <- nrow(dat) # copying original data test join

    dat <- inner_join(dat, grid, by = "RampID") 
    
    #'[#VALIDATE: TRUE, number of sites * number of trips == nrow(dat), unless sites have been removed eg. beach launching sites]
    
    t1*nrow(gridID_vis) == nrow(dat)
```
## Distance to BR

Distance from the boat ramp to the centroid of data points in each grid that launched from that boat ramp - if not takes centroid of grid cell. 


```{r message=FALSE}
#'[#NOTE:could wrap below bit in separate function - use_centroid and other could be site_centroid] 

    dat <- dat %>% 
      st_as_sf() # turn to sf object
    
    # get centroid of use points
    tmp <- dat %>%
      group_by(gridID_vis, RampID) %>%
      summarise(use_centroid = st_union(dat_geom)) %>%
      st_centroid() %>%
      ungroup() %>%
      mutate(id = row_number())
    
    # validation plot: is the use centroid in the middle of each set of uses per boat ramp
    # ggplot() +
    #   geom_sf(data = dat, aes(geometry = asc_geom)) +
    #   geom_sf(data = dat, aes(geometry = dat_geom, color = as.factor(RampID)), size = 0.25) +
    #   geom_sf(data = tmp, aes(geometry = use_centroid, color = as.factor(RampID)), shape = 8) +
    #   ggtitle("Check dots are in centroid of uses in cells for each boat ramp") +
    #   theme(plot.title = element_text(hjust = 0.5)) +
    #   theme_classic() +
    #   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    #         legend.spacing.y = unit(0.75, "cm"))
    
    # making distance data frame
    dist <- as.data.frame(round(set_units(st_distance(tmp, BRtrips), km), 2)) # distance from use centroid to each BR
    names(dist) <- unique(BRtrips$RampID) 
    dist$gridID_vis <- tmp$gridID_vis 
    dist$RampID <- tmp$RampID 
    dist$id <- tmp$id 
    len <- length(dist) - 3
    dist %<>% gather("BRdist", "use.centroid_km.br", 1:len) 
    dist[] <- sapply(dist, as.numeric) # change all cols to numeric
    
    dist <- dist %>% 
      filter(RampID == BRdist) %>% 
      dplyr::select(-c(id, BRdist)) %>% 
      rename(gridID_alt = gridID_vis) # got to join to alt not visited
    
    dat <- as.data.frame(dat)
    
    dat <- left_join(dat, dist, by = c("RampID", "gridID_alt")) # join
    
    dat <- dat %>% 
      mutate(km_BR = ifelse(is.na(use.centroid_km.br), site.centroid_km.br,
                            use.centroid_km.br)) # distance tc to be measured from
    
    # validation plot
    # ggplot(dat) +
    #   geom_sf(aes(geometry = asc_geom, fill = use.centroid_km.br), lwd = 0.25) +
    #   geom_sf(aes(geometry = br_geom), size = 3) +
    #   theme_classic() +
    #   scale_fill_distiller(palette = "Blues") +
    #   labs(fill = "km from BR", colour = "") +
    #   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    #         legend.spacing.y = unit(0.75, "cm")) +
    #   facet_grid(.~fac_br_id) +
    #   ggtitle("Check distances look accurate")
```

## Choice and travel cost ($0.54/km)
```{r choice and travel cost}
# 
 cons <- median(consump$consump)

      dat <- dat %>%
        filter(!is.na(Postcode)) %>% 
        # mutate(boat_size = ifelse(BoatLength <= 4.5, "S",
        #                           ifelse(BoatLength > 4.5 & BoatLength <= 6, "M",
        #                                  "L"))) %>% 
        mutate(boat_size = ifelse(BoatLength <= 3.75, "S", "L")) %>%
        left_join(consump[, c("boat_size", "consump", "speed")], by = "boat_size") %>%
        mutate(choice = ifelse(gridID_vis == gridID_alt, 1, 0)) %>%
        mutate(fc = round(as.numeric((cost/consump)*km_BR), 2))
        # mutate(fc = round(as.numeric((cost/cons)*km_BR), 2))
        # mutate(travelTime = round(site.centroid_km.br/speed, 2)) %>% 
        # left_join(vott[, c("Postcode", "ann_inc", "VOTT")]) %>% 
        # mutate(VOTT = round(VOTT*travelTime, 2)) %>% 
        # mutate(tc = round(VOTT + fc, 2))
  

    #'[#NOTE: Remember to add your interactions]  

    # dat %<>%
    #   mutate(blkm = BoatLength*offshore_dist) %>% 
    #   mutate(tcinc = tc*ann_inc) %>% 
    #   mutate(kmkids = kids*offshore_dist)

    #'[#VALIDATE: TRUE, should equal number of trips]
    sum(dat$choice) == n_distinct(dat$TripID)
```

## Filtering SZ
  - Current sz will have no data and therefore no value so are removed
  - Simulated sz that have no data have no value so are  removed
```{r}
    # Remove sites with no recreational value
    dat <- dat %>%  filter(sz_value == 1 | is.na(sz_value))
    
    # remove observations that have visited the current sz (removed above)
    sz_current_w_use <- setdiff(unique(dat$gridID_vis), unique(dat$gridID_alt))
    
    dat2 <- dat %<>% filter(!(gridID_vis %in% sz_current_w_use))
    
    #'[#VALIDATE: TRUE, no difference between gridID_alt/vis as every cells needs data]
  
     setdiff(unique(dat$gridID_vis), unique(dat$gridID_alt))
     setdiff(unique(dat$gridID_alt), unique(dat$gridID_vis))
     
    
     
    # removing sz columns
    sz_to_remove <- dat %>% 
      dplyr::select(num_range("sz", 1:100)) %>% 
      summarise_all(sum) 
    
    sz_to_remove <- names(sz_to_remove[, which(sz_to_remove %in% 0)])
     
    dat_rum_sf <- dat %>% dplyr::select(-c(sz_to_remove))
    dat_rum_df <- dat %>% dplyr::select(-c(sz_to_remove, asc_geom, br_geom, centroid, dat_geom))
    dat_df <- dat %>% dplyr::select(-c(asc_geom, br_geom, centroid, dat_geom))
    
    #'[#TODO: check this]  
    nrow(dat) == n_distinct(dat_df$gridID_alt) * n_distinct(dat_df$TripID)
```

# Save
```{r save}
    # full grid including sites with no recreational value
    saveRDS(dat, paste0("./data/gpkg/sims/2.1_ascCS_",sim_name ,"_4283.gpkg"))
    write_csv(dat_df, paste0("./data/02_data/2.1_asc_", sim_name,".csv"))
    
    # full grid excluding sites with no recreational value
    saveRDS(dat_rum_sf, paste0("./data/gpkg/sims/2.1_ascCS_rum_", sim_name,"_4283.gpkg")) # script 3.1
    write_csv(dat_rum_df, paste0("./data/02_data/2.1_asc_rum_", sim_name,".csv")) # stata
    
    # simplified ascGrid for QGIS (geom, ID)
    st_write(gridID_vis,
             paste0("./data/gpkg/sims/2.1_ascCSQ", sim_name, "_4283.gpkg"),
             append = FALSE) # need to write with st_write to open in QGISRUMs
```
