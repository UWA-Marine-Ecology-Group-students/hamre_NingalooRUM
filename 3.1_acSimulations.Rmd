# Setup
```{r setup, include = FALSE}
  rm(list = ls())

knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, cache = TRUE, fig.align = 'center', fig.width = 10, fig.height = 7) 

# libraries
library(tidyverse)
library(readxl)
library(magrittr)
library(MASS)
library(matrixStats)
library(dplyr)
library(data.table)
library(gtable)
library(gridExtra)
library(sp)
library(raster)
library(rgeos)
library(rgdal)
library(sf)

# data
# BRtrips <- readRDS("./data/gpkg/BRtrips_KR_4283.gpkg") # Korinna Ryans BR estimates
BRtrips <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") # This is produced by "BRtrips.R" in function folder

# simulation 
model <- "asc_attatasc" #'[#NOTE: choose model] 
sim <- "sim1" #'[#NOTE: choose simulation] 
cost <- "fcflt_spgam"  #'[#NOTE: choose cost variable] # not needed for attatasc

b <- read_excel(paste0("./data/03_data/", model, ".xlsx")) # coef
a <- nrow(b) + 2
v <- read_excel(paste0("./data/03_data/", model, ".xlsx"), sheet = "v", col_names = rep("x", a)) %>% distinct() # covariance cases

# dat <- readRDS(paste0("./data/gpkg/sims/2.1_ascCS_rum_", sim ,"_4283.gpkg")) # for when no data is models eg. catch rate
dat <- read_csv(paste0("./data/02_data/2.3_asc_dat_", sim, ".csv")) # for when  data is models eg. catch rate
# dat <- read_csv("./data/02_data/2.3_dat_att.csv") # attribute


# plotting data
# mp <- st_read("./data/gpkg/pmmp_4326.gpkg")
# # mp_bbox <- st_read("./data/gpkg/pscmpBbox_4326.gpkg")
# NPZ <- st_read("./data/gpkg/ntz_4283.gpkg")

# source
# source("./functions/theme.R")
```

# Wrangle data
    - dat: contains a row for  (nrow(dat)) = every available option (n grid cells, excluding current sz and sim sz with no recreational value) * per trip (n trips). The choice            column indicated what column the recreator actually chose. 

    - b:  

```{r rearrange, include = FALSE}
    #'[#VALIDATE: TRUE, check dat has correct number of rows]
    nrow(dat) == n_distinct(dat$gridID_alt) * n_distinct(dat$TripID)

    # grid <- dat %>% as.data.frame() %>%
    #     distinct(gridID_alt, .keep_all = TRUE) %>% # nrow(grid) == number of available options
    #     dplyr::select(gridID_alt, asc_geom) %>%
    #     st_as_sf()
    
    b %<>% rename(cov = ...1) %>% 
      # mutate(gridid_alt = ifelse(Vars %in% "travelcost", "tc", gridid_alt)) %>% 
      mutate(cov = ifelse(!(Vars %in% "_cons"), Vars, cov)) %>% 
      dplyr::select(-Vars)
  
    v %<>% 
      # mutate(x...1 = ifelse(x...2 %in% "travelcost", "tc", x...1)) %>%  
      mutate(x...1 = ifelse(!(x...2 %in% "_cons"), x...2, x...1)) %>%  
      dplyr::select(-x...2) %>% 
      distinct()
  
    colnames(v) <- c("vars", v$x...1)
    v %<>% dplyr::select(-vars)
    vars <- b$cov #use

    #'[#VALIDATE: TRUE/TRUE/check min and max, extreme values will skew model (issue 2.1?)]
    nrow(b) == length(v) # should be true
    length(v) == nrow(v) # should be true
    summary(b$Coef) # check min and max, the more extreme the values the more inflated or deflated the results will be. Most likely a problem with script 2.1 or model.
```

# Error 
Generates coefficients drawn from within the ci of each variable. Draws n1 numbers (nrow) from within a multivariate normal distribution for each variable (length); mu = vector of means, Sigma = covarience matrix
```{r error, include = FALSE}
    n1 <- 1000 # number of samples (all estimates)
    mvn_b <- mvrnorm(n1, mu = b$Coef, Sigma = as.matrix(v)) 

# checkpoint
dim(mvn_b)[1] == n1 # should be true
dim(mvn_b)[2] == nrow(b) # should be true
```

# Utility
Calculate the utility (Vj) for every alternative, each individual observation in dat represents an alternative. 

We expect recreator  (i) to choose the site (j) with the highest expected utility. The utility  (Vj) of a site is a function of the observed attributes (B) of those sites and associated error (e).

      Vj = B(depth, travel cost etc.) + e 

```{r utility, include = FALSE}
# calculate utility
      
      # define vars used in RUM
      bid <- unique(b$cov) 
      id_vars <- dat %>% dplyr::select(num_range("gridID_", bid)) # extract grid IDs
      
      bsite <- bid[str_detect(bid, "[a-zA-Z]")] 
      site_vars <- dat %>% dplyr::select(contains(bsite)) # extract attributes
      
      vars <- c(names(site_vars), names(id_vars)) #'[#NOTE: add factor vars]
      
    # turn defined vars into matrix from dat, make sure there is no geometry
      rum_matrix <- as.matrix(dat[, vars])
      
    # create an empty utility matrix
        Vj <- matrix(NA, nrow = nrow(rum_matrix), ncol = n1) 
        
    # calculate observed utility for every alternative (nrows), n1 times from
    # multivariate random normal distribution. %*% is a matrix multiplication where...
    # We are multiplying the values in the rum_matrix (real data) by the error  
    # coefficients matrix (mvn_b)? so we have 100 utility values for each variable - why? 
    
        for (i in 1:n1) { 
          Vj[ ,i] <- as.vector(rum_matrix %*% as.matrix(mvn_b[i,]))  
        }
        
        Vj <- exp(Vj) # get exponential of utility
        
        #'[#VALIDATE: TRUE, exp(Vj) should make all values positive]
       identical(which( Vj < 0), integer(0))
       which(is.infinite(as.matrix(Vj)))
       
    
```

The probability of a recreator (i) choosing site (j) is the exponential of the the utility of the site (j) divided by the sum of the utility of all the potential alternatives the recreator could have choosen (including site j). This is a conditional logit formula. 

    probj = exp(Vj)/sum(exp(Vj))
    
```{r Probabilities, include = FALSE}
# Probabilities

    Vj <- as.data.table(Vj) # make data.table to save RAM
    cols <- colnames(Vj) # save the names of the draws for later
    Vj$br <- as.integer(dat$RampID) # run function by BR
    Vj$ID <- as.integer(dat$gridID_alt) # add gridID_alt for group_by
    Vj$tc <- dat$nl_fcflt_spgam # add travel cost

    # Calculate probability of visit and logsums: pre-simulation
    f1 <- function(x) if (is.integer(x)) {x} else {x/sum(x)}

    p <- Vj[ , lapply(.SD, f1), by = br, .SDcols = c(cols, "ID")] # applying probability function to every cell in Vj by boat ramp
    p <- p[order(br, ID)] # ordering
    dat %<>% arrange(RampID, gridID_alt) # ordering
    
    #'[#VALIDATE: TRUE, should be the same so you can append probabilities]
    table(dat$gridID_alt == p$ID)
    
    nrow(dat) == nrow(p) 
    
    p <- p[ , br := NULL] # remove
    p <- p[ , ID := NULL] # remove
    p <- as.matrix(p)   # make matrix
    
    #'[#VALIDATE: TRUE, sum(p(each site from br)) == 1, so sum(p(each site from every         boat ramp)) == #boat ramps]
    
    sum(p[,1])
    n_distinct(dat$RampID)

    # Adds probability statistics (lower ci, median, upper ci) to each row of dat. This is the probability that people will visit site (gridID_alt) pre-simulation. 
    # Summary stats are calculated across each row in p (rowQuantiles), length == n1

    dat$p.mean_base <- rowQuantiles(p, probs = sqrt(0.5)) # lower ci
    dat$p.low_base <- rowQuantiles(p, probs = sqrt(0.025)) # lower ci
    dat$p.upp_base <- rowQuantiles(p, probs = 1 - sqrt(0.025)) # upper ci 
    
    # alternatives presented to the person - sum of exp(Vj)
     logsum_base <- Vj[ , lapply(.SD, sum), by = br, .SDcols = cols]
    
     sum(dat$choice) # should be ntrips
    n_distinct(dat$PersonID) # why is there only 4 trips 

    # save output
    # write.csv(dat, "./ignore/03_data/3.1_basedat.csv")
    # write.csv(logsum_base, "./ignore/03_data/3.1_logsum_base.csv")


```

```{r closures, include = FALSE}
# Assign closures
  sz_vars <- dat %>% 
    dplyr::select(gridID_alt, sz) %>% 
    filter(sz == 1) %>% 
    distinct(gridID_alt)
  
   ntz <- unique(sz_vars$gridID_alt) 

# Calculate probability of visit and logsums: post-simulation
    Vj[Vj$ID %in% ntz, cols] <- 0
    p <- Vj[ , lapply(.SD, f1), by = br, .SDcols = c(cols, "ID")]
    p <- p[order(br, ID)]
    dat %<>% arrange(RampID, gridID_alt)
    table(dat$gridID_alt == p$ID) # should all be true
    
    logsum_sim <- Vj[ , lapply(.SD, sum), by = br, .SDcols = cols] # 18876 trips
    
    p <- p[ , br := NULL]
    p <- p[ , ID := NULL]
    p <- as.matrix(p)
    
# Calculates probability of visit summary statistics by row. This is the simulated probability of each site, for each trip and the error. 

    dat$p.mean_sim <- rowQuantiles(p, probs = sqrt(0.5)) # lower ci
    dat$p.low_sim <- rowQuantiles(p, probs = sqrt(0.025)) #saving outputs back to p
    dat$p.upp_sim <- rowQuantiles(p, probs = 1 - sqrt(0.025)) #Note below about weird probs
```

# Extract Welfare
```{r welfare, include = FALSE}
# Extracting the welfare impact
    W <- log(logsum_sim[, -1]) -  log(logsum_base[, -1])
    W <- t(W)/mvn_b[ ,1] # length of this does not match n1/mvn_b
    W <- t(W)

# Summaries across draws
    W <- as.matrix(W)
    logsum_sim$w.mean <- rowQuantiles(W, probs = sqrt(0.5)) # median
    logsum_sim$w.low <- rowQuantiles(W, probs = sqrt(0.025)) # lower ci
    logsum_sim$w.upp <- rowQuantiles(W, probs = 1 - sqrt(0.025)) # upper ci
    # logsum_sim$upp.ci <- logsum_sim$w.upp - logsum_sim$w.mean
    
    dat %<>%  mutate(RampID = as.integer(RampID))
  
    dat %<>% left_join(logsum_sim[ , c("br", "w.mean", "w.upp", "w.low")], by = c("RampID" = "br"))

    # # Welfare impact of closure
    W_impact_trip <- logsum_sim %>%
      summarise("Annual lower welfare impact per trip ($)" = round(sum(w.low), 2),
                "Annual mean welfare impact per trip ($)" = round(sum(w.mean), 2),
                "Annual upper welfare impact per trip ($)" = round(sum(w.upp), 2))

    W_impact_trip
    # png("./plots/ASC RUM/ac_sim_og_impact_trip.png", height = 50*nrow(W_impact_trip), width =
    #       200*ncol(W_impact_trip))
    # grid.table(W_impact_trip)
    # dev.off()

# save output
  # write.csv(dat, "./ignore/03_data/3.1_Wsimdat.csv")
  # write.csv(logsum_sim, "./ignore/03_data/3.1_logsum_sim.csv")
```
## Annual Impact

This chunk merges estimates of trip numbers at each ramp each annually (BRtrips) with estimates of the probability of visiting each grid (by annually) given a particular boat ramp was selected (dat). 

-   Number of annual trips per br \* the W impact of each br

Multiplied br numbers by corresponding probabilities. Note that because we adjusted the probs above to sqrt(0.025) we should now have accurate 95% CIs. 

```{r br multiplication gravity, include = FALSE}

dat %<>% left_join(.,BRtrips, by = "RampID", suffix = c("", "_Ramp"))

    RUM_W <- dat %>% distinct(.,RampID, .keep_all = TRUE) %>%
      # gravity function
      mutate(across(starts_with("TRIPS_ramp_prop"), ~.x*w.mean, .names = "welf_mean_{.col}" ),
             across(starts_with("upp_TRIPS"), ~.x*w.upp, .names = "welf_upp_{.col}" ),
             across(starts_with("low_TRIPS"), ~.x*w.low, .names = "welf_low_{.col}" )) 
      # dprid
      # mutate(across("dprid_br_mean", ~.x*w.mean, .names = "welf_mean_{.col}" ),
      #        across("dprid_br_uci", ~.x*w.upp, .names = "welf_upp_{.col}" ),
      #        across("dprid_br_lci", ~.x*w.low, .names = "welf_low_{.col}" ))

# Annual Impact
    grav_impact <- RUM_W %>% summarise(round(across(starts_with(c("welf_low_low", "welf_mean_TRIPS","welf_upp_upp")), sum)))
 
    # dprid_impact <- RUM_W %>% summarise(round(across(starts_with(c("welf_low_dprid", "welf_mean_dprid","welf_upp_dprid")), sum)))
    
    # w_impact <- as.data.frame(cbind(grav_impact, dprid_impact)) %>% 
    #   pivot_longer(cols = 1:6) %>% 
    #   rename(value = name,
    #          ann_impact = value)
  
   grav_impact
    
    # write_csv(w_impact, paste0("./data/03_data/3.1_ann_impact_", sim,".csv"))
```

# Welfare impacts
```{r totW, include = FALSE}
W_impact <- RUM_W %>% summarise(round(across(starts_with(c("welf_low", "welf_mean","welf_upp")), sum)))

W_impact %<>%  rename("Annual lower impact ($)" = welf_low_low_TRIPS_Grvt__5,
                      "Annual mean  impact ($)" = welf_mean_TRIPS_ramp_prop_Grvt__5,
                      "Annual upper impact ($)" = welf_upp_upp_TRIPS_Grvt__5)

W_impact
png("./plots/ASC RUM/ac_s1.W_impact.png", height = 50*nrow(W_impact), width = 200*ncol(W_impact))
grid.table(W_impact)
dev.off()

```

```{r sc_spimpact, include = FALSE}
RUM_grid %<>%
     mutate(mean_diff = mean_sim_TRIPS_ramp_prop_Grvt__5 - mean_base_TRIPS_ramp_prop_Grvt__5,
            upp_diff = upp_sim_upp_TRIPS_Grvt__5 - upp_base_upp_TRIPS_Grvt__5,
            low_diff = low_sim_low_TRIPS_Grvt__5 - low_base_low_TRIPS_Grvt__5)
```


```{r}
presim <- ggplot(RUM_grid) +
      xlab("Longitude") + ylab("Latitude") +
      geom_sf(aes(fill = mean_base_TRIPS_ramp_prop_Grvt__5), lwd = 0.05) +
      scale_fill_distiller(palette = "YlGnBu", direction = 1) +
      labs(fill = "Trips\nannually") +
  my_theme +
   # geom_sf(data = BRtrips, color = 'red', fill = 'red', size = 0.75) +
  ggtitle(" Pre-simulation ")

RUM_grid %<>% filter(mean_diff >= 0)

postsim <- ggplot(RUM_grid) +
      xlab("Longitude") + ylab("Latitude") +
      geom_sf(aes(fill = mean_sim_TRIPS_ramp_prop_Grvt__5), lwd = 0.05) +
      scale_fill_distiller(palette = "YlGnBu", direction = 1) +
      labs(fill = "Trips\nannually") +
  my_theme +
   ggtitle(" Post-simulation ")
  # geom_sf(data = mp, alpha = 0, lwd = 0.25) +
  # geom_sf(data = NPZ, lwd = 0.25) +
  # geom_sf(data = sp_mpbr, color = 'red', fill = 'red', size = 0.5)

diff <- ggplot(RUM_grid) +
      xlab("Longitude") + ylab("Latitude") +
      geom_sf(aes(fill = mean_diff), lwd = 0.05) +
      scale_fill_distiller(palette = "YlGnBu", direction = -1) +
      labs(fill = "Change in\nannual trips") +
      my_theme 
    # geom_sf(data = mp, alpha = 0, lwd = 0.25) +
    # geom_sf(data = NPZ, lwd = 0.25) +
  # geom_sf(data = BRtrips, color = 'red', fill = 'red', size = 0.5) 
  # geom_sf(data = sim, lwd = 0.05, fill = "black")

presim
postsim
diff

```

# save outputs
```{r}
ggsave(presim, path = "./plots/ASC RUM", filename = paste("acPresim_", sim, ".png", sep = ''), width = 4, height = 4)

ggsave(postsim, path = "./plots/ASC RUM", filename = paste("acPostsim_", sim, ".png", sep = ''), width = 4, height = 4)

ggsave(diff, path = "./plots/ASC RUM", filename = paste("acDiff_", sim, ".png", sep = ''), width = 4, height = 4)
```


## Welfare impacts per boat ramp
```{r welfare_bar, include = FALSE}
# RUM_W$BR <- as.factor(RUM_W$BR)
# 
# W_BRimpact <- RUM_W %>% group_by(BR, Ramp_name) %>%
#       summarise(round(across(starts_with(c("welf_low", "welf_mean","welf_upp")), sum))) %>% 
#   filter(welf_mean_TRIPS_ramp_prop_Grvt__5 > 0)
# 
# W_BRimpact_bar <- W_BRimpact %>%
#   ggplot(.) +
#   geom_bar(aes(x = BR, y = welf_mean_TRIPS_ramp_prop_Grvt__5), stat = "identity",  fill = col) +
#   geom_errorbar(aes(x = BR, ymin = welf_low_low_TRIPS_Grvt__5, ymax = welf_upp_upp_TRIPS_Grvt__5), width = 0.2) +
#   my_theme +
#   scale_x_discrete(drop = T, labels = W_BRimpact$Ramp_name) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
#   ylab("Annual welfare impacts on\nrecreational fishers ($)") +
#   xlab("Boat Ramp")
# 
# W_BRimpact_bar
# ggsave(path = "./plots", filename = paste("sim1.W_BRimpact_bar.png", sep = ''), plot = W_BRimpact_bar, width = 8, height = 4)
# 
# 
# W_BRimpact %<>%  rename("Annual lower welfare impact ($)" = welf_low_low_TRIPS_Grvt__5,
#                         "Annual mean welfare impact ($)" = welf_mean_TRIPS_ramp_prop_Grvt__5,
#                         "Annual upper welfare impact ($)" = welf_upp_upp_TRIPS_Grvt__5)
# 
# W_BRimpact
# png("./plots/sim1.W_BRimpact.png", height = 50*nrow(W_BRimpact), width = 150*ncol(W_BRimpact))
# grid.table(W_BRimpact)
# dev.off()

```

```{r}
# for (i in W_BRimpact$BR) {
#   br <- BRtrips %>% filter(RampID %in% i)
# bbox <- RUM_grid %>%  filter(BR %in% i)
# mp_crop <- mp %>% st_crop(bbox)
# mp_comm <- NPZ %>% st_crop(bbox)
# 
# presim <- RUM_grid %>% filter(BR == i) %>%
#     ggplot(.) +
#       xlab("Longitude") + ylab("Latitude") +
#       geom_sf(aes(fill = mean_base_TRIPS_ramp_prop_Grvt__5), lwd = 0.05) +
#       scale_fill_distiller(palette = "YlGnBu", direction = 1) +
#       labs(fill = "Trips\nannually") +
#       my_theme +
#     geom_sf(data = mp_crop, alpha = 0, lwd = 0.25) +
#   geom_sf(data = mp_comm, alpha = 0, lwd = 0.25) +
#   ggtitle(paste(br$Ramp_name, " pre-simulation ")) +
#   geom_sf(data = br, color = 'red', fill = 'red', size = 1)
# 
# ggsave(path = "./plots", filename = paste("sim1.", br$Ramp_name,"_presim.png", sep = ''), plot = presim, width = 8, height = 4)
# print(presim)
# 
# sim <- RUM_grid %>% filter(BR == i & gridID_alt %in% ntz)
# 
# postsim <- RUM_grid %>% filter(BR == i) %>%
# ggplot(.) +
#       xlab("Longitude") + ylab("Latitude") +
#       geom_sf(aes(fill = mean_sim_TRIPS_ramp_prop_Grvt__5), lwd = 0.05) +
#       scale_fill_distiller(palette = "YlGnBu", direction = 1) +
#       labs(fill = "Trips\nannually") +
#   geom_sf(data = mp_crop, alpha = 0, lwd = 0.25) +
#   geom_sf(data = mp_comm, alpha = 0, lwd = 0.25) +
#   geom_sf(data = br, color = 'red', fill = 'red', size = 1) +
#   geom_sf(data = sim, fill = "black", lwd = 0.05) +
#   ggtitle(paste(br$Ramp_name, " post-simulation")) +
#   my_theme
# 
# ggsave(path = "./plots", filename = paste("sim1.", br$Ramp_name,"_postsim.png", sep = ''), plot = postsim, width = 8, height = 4)
# print(postsim)
# }
```

```{r difference plots}
# RUM_grid %<>%
#      mutate(mean_diff = mean_sim_TRIPS_ramp_prop_Grvt__5 - mean_base_TRIPS_ramp_prop_Grvt__5,
#             upp_diff = upp_sim_upp_TRIPS_Grvt__5 - upp_base_upp_TRIPS_Grvt__5,
#             low_diff = low_sim_low_TRIPS_Grvt__5 - low_base_low_TRIPS_Grvt__5)
# 
# for (i in W_BRimpact$BR) {
#   br <- BRtrips %>% filter(RampID %in% i)
#   bbox <- RUM_grid %>%  filter(BR %in% i)
#   mp_crop <- mp %>% st_crop(bbox)
#   mp_comm <- NPZ %>% st_crop(bbox)
#   sim <- RUM_grid %>% filter(BR == i & gridID_alt %in% ntz)
#   
# diff <- RUM_grid %>% filter(BR == i) %>%
#     ggplot(.) +
#       xlab("Longitude") + ylab("Latitude") +
#       geom_sf(aes(fill = mean_diff), lwd = 0.05) +
#       scale_fill_distiller(palette = "YlGnBu", direction = -1) +
#       labs(fill = "Change in\nannual trips") +
#       my_theme +
#     geom_sf(data = mp_crop, alpha = 0, lwd = 0.25) +
#     geom_sf(data = mp_comm, alpha = 0, lwd = 0.25) +
#       ggtitle(paste(br$Ramp_name)) +
#   geom_sf(data = sim, fill = "black", lwd = 0.05) +
#     geom_sf(data = br, color = 'red', fill = 'red', size = 1)
# 
# ggsave(path = "./plots", filename = paste("sim1.", br$Ramp_name,"_diff.png", sep = ''), plot = diff, width = 8, height = 4)
# print(diff)
# }
```