# Set up
```{r setup}
    rm(list = ls())

    # knitr options
    knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, fig.align = 'center',
                          fig.width = 10, fig.height = 7) 
    
    # libraries 
    library(tidyverse)
    library(dplyr)
    library(ggplot2)
    library(sp)
    library(raster)
    library(rgeos)
    library(rgdal)
    library(sf)
    library(googledrive)
    library(units)
    library(nngeo)
    library(sfnetworks)
    # library(windfetch)
    
    # functions
    source("./functions/spatialFunc.R") # spatial functions
    
    # spatial data
    ## gpkg - ESPG 4283 (GDA94)
    ## raster - ESPG 4326 (WGS84)

    BR <- readRDS("./data/gpkg/2.1_BRtrips.gpkg") %>% st_transform(crs = 4283) # from BRtrips.R
    
    coast <- st_read("./data/gpkg/coast.gpkg") %>%  st_transform(4283)
    
    ext <- st_read("./data/gpkg/model_extent_v3.gpkg") %>% st_transform(4283) # study site (mega mvm polygon)
    
    # artInfra <- st_read("./data/gpkg/ArtReef.gpkg")
    
    # ntz <- st_read("./data/gpkg/ntz.gpkg") # commonwealth and current state NTZ
    ntz <- st_read("./data/gpkg/ning_sim+sz.gpkg") %>%  st_transform(4283)# commonwealth and current state NTZ

    
     habitat <- st_read("./data/gpkg/ning_hab.gpkg") %>% 
      st_transform(crs = 4283) %>% 
      st_make_valid() %>% 
      mutate(habitat = tolower(habitat))
    
    bathy <- raster("./data/raster/NWSbathy.tif") # bathy
    
    sf_use_s2(FALSE)
    
    # check layers
    # ggplot() +
    # # # geom_sf(data = tmp, lwd = 0.05)
    # geom_sf(data = ext, lwd = 0.05) +
    # # # geom_sf(data = coast) +
    # # # geom_sf(data = BR, colour = 'red') +
    # geom_sf(data = ntz, fill = "green")
    
    # ggplot() +
    #   geom_sf(data = habitat, aes(fill = habitat), lwd = 0.1)
```


# Make grid
```{r}
  grid <- st_difference(ext, st_union(st_combine(ntz))) # cut npz out of sims

  grid <- st_make_grid(grid, cellsize = 0.05, square = FALSE, crs = 4283) %>% 
    st_intersection(grid) %>% 
    st_as_sf() %>% 
    mutate(ntz = 0)
  
  
  grid$area <- round(set_units(st_area(grid), km^2), 2) 

  grid %<>% mutate(area = as.numeric(area)) 

   
   # grid %<>% filter(area >= 3)
   
  # ggplot() +
  #   geom_sf(data = grid, aes(fill = area), lwd = 0.05)
  
  ntz_grid <- st_make_grid(ext, cellsize = 0.05, square = FALSE, crs = 4283) %>% 
    st_intersection(ntz) %>% 
    st_as_sf() %>% 
    mutate(ntz = 1)
  
  ntz_grid$area <- round(set_units(st_area(ntz_grid), km^2), 2) 

  ntz_grid %<>% mutate(area = as.numeric(area)) 

   
  # ntz_grid %<>% filter(area >= 3)
  
  # ggplot() +
  #   geom_sf(data = ntz_grid, aes(fill = area), lwd = 0.05)
  
  grid <- rbind(grid, ntz_grid)
  
  grid %<>% 
    mutate(gridid = row_number()) %>% 
    rename(grid_geom = x)

   ggplot() +
    geom_sf(data = grid, aes(fill = area), lwd = 0.05) + theme_classic()
```

# Attributes
## Depth
Calculates the average depth within each grid cell (site). This does work is after grid manipulation.
```{r depth}
    grid <- mean_depth(bathy, grid) # get average depth of grid
    grid$depth <- abs(grid$depth)
    
    ggplot() +
      geom_sf(data = grid, aes(fill = depth), lwd = 0.05) + 
      scale_fill_continuous(trans = 'reverse') +
      theme_classic()
```

## Rugousity
```{r}
rug <- terra::terrain(bathy, v = c("roughness"))

rugousity <- raster::extract(rug, grid, na.rm = TRUE, fun = max)

grid$rug <- as.numeric(rugousity)

# check
plot(rug) 

ggplot() +
  geom_sf(data = grid, aes(fill = rug), lwd = 0.05) + theme_classic()
```

## Centroid
```{r}
    centroid <- st_centroid_within_poly(grid$grid_geom) # gets centroid of every grid cell
    grid$centroid <- centroid # bind centroid to grid sf 
    
    ggplot() +
      geom_sf(data = grid$centroid, size = 0.05) + theme_classic()
```

## Habitat
Calculates the area (km2) of each habitat type in each individual grid cell (site)
```{r habitat}
# grid <- habitat_area(sf_habitat = habitat, col_habitat = 1, sf_grid = grid, id_grid = gridID) # need to update updated pivot wioder from spread
  habitat %<>% st_make_valid()
  hab <- st_intersection(habitat, grid) # This gives you all the individual areas where there is overlap between the habitat and grid, includes original ID
  hab <- st_make_valid(hab) # make intersection valid
  hab$hab_area <- round(set_units(st_area(hab), km^2), 2) # calculate the are of each habitats in intersection grids
  hab %<>% mutate(hab_area = as.numeric(hab_area)) 
  hab <- hab %>% pivot_wider(names_from = "habitat", values_from = "hab_area", values_fill = 0)
  
  habs <- unique(habitat$habitat)
  
  hab_grid <- hab %>%
    group_by(gridid) %>%
    summarise_at(habs, .funs = sum) %>%
    ungroup() %>%
    st_drop_geometry()
  
  #'[#VALIDATE: If grid and hab_grid do not have the same rows than some grids are out with the habitat layer. check to see what these or so they can be filled in or removed]

  
  # nrow(grid) == nrow(hab_grid)
  # 
  # diff <- grid %>% filter(gridID %in% c(setdiff(grid$gridID, hab_grid$gridID)))
  #   
  # ggplot() +
  #   geom_sf(data = grid, lwd = 0.05) +
  #   geom_sf(data = diff, fill = "red", lwd = 0.05)

  # all are at the very edges and are pelagic
    
  grid %<>% left_join(hab_grid, by = "gridid")
  

# checks
which(grid$lagoon > grid$area)
which(grid$rreef > grid$area)
which(grid$reef > grid$area)

summary(grid$lagoon)
summary(grid$rreef)
summary(grid$reef)

ggplot()+
  geom_sf(data = grid, aes(fill = lagoon), lwd = 0.05)
ggplot()+
  geom_sf(data = grid, aes(fill = rreef), lwd = 0.05)
ggplot()+
  geom_sf(data = grid, aes(fill = reef), lwd = 0.05)

grid %<>% 
  mutate(reefs = rreef + reef) %>%  # sum reefs into one
  mutate_at(c("lagoon", "reefs"), ~replace_na(.,0))
```

## Land
Distance to mainland: Calculates the linear distance from the centroid of every grid cell (site) to the nearest point on mainland.
Adjacent to land: Creates binary list indicating whether there is an island are adjacent to grid cell (site).

```{r land present}
coast %<>% st_cast("POLYGON")
coast$area <- as.numeric(set_units(st_area(coast), km^2)) # area of polygons in coast sf

# Distance from mainland
## extracting mainland from coast polygon
mainland <- coast %>% 
  arrange(desc(area)) %>% 
  slice(1)

# ## calculate distance form mainland
km_mainland <- dist_mainland(grid$centroid, mainland)
# 
grid$km_mainland <- km_mainland[,1]

# Adjacent to land
## extracting islands from coast polygon
islands <- coast %>%
  arrange(desc(area))  %>%
  slice(2:nrow(coast))

## create binary column indicating whether grid cell is adjacent to island
grid %<>%
  mutate(isl_adj = ifelse(as.list(st_intersects(grid, islands)) %in% "integer(0)", 0, 1)) %>% 
  mutate(isl_adj = as.factor(isl_adj))

# checkpoint
ggplot() +
  geom_sf(data = grid, aes(fill = km_mainland), lwd = 0.05) + theme_classic()

ggplot() +
  geom_sf(data = grid, aes(fill = isl_adj), lwd = 0.05) + theme_classic()
```

## Dist to BR
Calculates the linear and non-linear distance from each boat ramp to every centroid.

```{r distance to BR}
  # create distanec matrix
  dist <- dist(grid$centroid, BR$geometry, BR$RampID, grid$gridid) # create distance dataframe
  BR %<>% mutate(RampID = as.character(RampID)) 

  dist %<>% left_join(BR[, c("RampID", "geometry")]) # append ramp geom
  
  # append distance to grid
  grid %<>% left_join(dist, by = "gridid") # join to input data
  nrow(grid) == n_distinct(grid$gridid)*nrow(BR) # check dataset is the correct size
  
  grid %<>% rename(br_geom = geometry) 

    ggplot(grid) +
      geom_sf(aes(geometry = grid_geom, fill = nl_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = br_geom, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Non-linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
    
    ggplot(grid) +
      geom_sf(aes(geometry = grid_geom, fill = l_km_br), lwd = 0.25) +
      geom_sf(aes(geometry = br_geom, colour = as.factor(RampID)), size = 3) +
      theme_classic() +
      scale_fill_distiller(palette = "Blues") +
      labs(fill = "Linear km from BR", colour = "") +
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
            legend.spacing.y = unit(0.75, "cm")) +
      facet_grid(.~RampID) +
      ggtitle("Check distances look accurate")
```

## Artificial infrastructure present
Creates binary list indicating whether there is artificial infrastructure present in grid cell (site)
```{r artificial infrastructure present}
# waterGrid$ArtInfra_present <- as.numeric(st_intersects(artInfra, waterGrid, sparse = FALSE)) 
```

## Fetch
```{r fetch}
# coast_lambert <- coast %>% st_transform(crs = 3112) # need land lambert
# 
# cent <- waterGrid %>%  st_drop_geometry() %>% st_as_sf() # dropping geom
# 
# fetch <- windfetch(polygon_layer = coast_lambert, site_layer = cent) # calc fetch
```

## Shelter
```{r}
# shelter <- shelter %>% st_transform(crs(coast))
# waterShelter <- st_difference(shelter, st_combine(coast)) # isolate
# 
# ggplot() +
#   geom_sf(data = waterShelter)

# shelter_grids <- as.data.frame(st_within(waterGrid, waterShelter, sparse = FALSE))
# 
# shelter_grids <- shelter_grids %>%
#   rowwise %>%
#   mutate(shelter = if_any(.cols = contains('V'), isTRUE)) %>%
#   ungroup
# 
# waterGrid <- waterGrid %>%
#   mutate(shelter = ifelse(shelter_grids$shelter %in% TRUE, 1, 0))

# ggplot() +
#   geom_sf(data = waterGrid, aes(fill = shelter), lwd = 0.05)
```

# Save output
```{r save}
saveRDS(grid, "./data/gpkg/2.0_Sites_4283.gpkg")

st_write(grid, "./data/gpkg/2.0_SitesQ_4283.gpkg") # for QGIS
```